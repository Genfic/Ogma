/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class RssClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	stories(): Promise<FileResponse> {
		let url_ = this.baseUrl + "/rss";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processStories(_response);
		});
	}

	protected processStories(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	getStories(): Promise<FileResponse> {
		let url_ = this.baseUrl + "/rss/stories";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetStories(_response);
		});
	}

	protected processGetStories(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	getBlogposts(): Promise<FileResponse> {
		let url_ = this.baseUrl + "/rss/blogposts";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetBlogposts(_response);
		});
	}

	protected processGetBlogposts(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}
}

export class CommentsClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getComments(thread: number | undefined, page: number | null | undefined, highlight: number | null | undefined): Promise<PaginationResultOfCommentDto> {
		let url_ = this.baseUrl + "/api/comments?";
		if (thread === null)
			throw new Error("The parameter 'thread' cannot be null.");
		else if (thread !== undefined)
			url_ += "thread=" + encodeURIComponent("" + thread) + "&";
		if (page !== undefined && page !== null)
			url_ += "page=" + encodeURIComponent("" + page) + "&";
		if (highlight !== undefined && highlight !== null)
			url_ += "highlight=" + encodeURIComponent("" + highlight) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetComments(_response);
		});
	}

	protected processGetComments(response: Response): Promise<PaginationResultOfCommentDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = PaginationResultOfCommentDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<PaginationResultOfCommentDto>(<any>null);
	}

	putComment(data: CommentsControllerPatchData): Promise<CommentDto> {
		let url_ = this.baseUrl + "/api/comments";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "PATCH",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPutComment(_response);
		});
	}

	protected processPutComment(response: Response): Promise<CommentDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CommentDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<CommentDto>(<any>null);
	}

	postComment(data: CommentsControllerPostData): Promise<CommentDto> {
		let url_ = this.baseUrl + "/api/comments";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostComment(_response);
		});
	}

	protected processPostComment(response: Response): Promise<CommentDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CommentDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<CommentDto>(<any>null);
	}

	getRevisions(id: number): Promise<CommentRevisionDto[]> {
		let url_ = this.baseUrl + "/api/comments/revisions/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetRevisions(_response);
		});
	}

	protected processGetRevisions(response: Response): Promise<CommentRevisionDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(CommentRevisionDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<CommentRevisionDto[]>(<any>null);
	}

	getComment(id: number): Promise<CommentDto> {
		let url_ = this.baseUrl + "/api/comments/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetComment(_response);
		});
	}

	protected processGetComment(response: Response): Promise<CommentDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CommentDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<CommentDto>(<any>null);
	}

	deleteComment(id: number): Promise<CommentDto> {
		let url_ = this.baseUrl + "/api/comments/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteComment(_response);
		});
	}

	protected processDeleteComment(response: Response): Promise<CommentDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CommentDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<CommentDto>(<any>null);
	}

	getMarkdown(id: number | undefined): Promise<string> {
		let url_ = this.baseUrl + "/api/comments/md?";
		if (id === null)
			throw new Error("The parameter 'id' cannot be null.");
		else if (id !== undefined)
			url_ += "id=" + encodeURIComponent("" + id) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetMarkdown(_response);
		});
	}

	protected processGetMarkdown(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class CommentsThreadClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getPermissions(id: number): Promise<CommentsThreadControllerPermissionsResult> {
		let url_ = this.baseUrl + "/api/commentsthread/permissions/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetPermissions(_response);
		});
	}

	protected processGetPermissions(response: Response): Promise<CommentsThreadControllerPermissionsResult> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CommentsThreadControllerPermissionsResult.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<CommentsThreadControllerPermissionsResult>(<any>null);
	}

	getLockStatus(id: number): Promise<boolean> {
		let url_ = this.baseUrl + "/api/commentsthread/lock/status/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetLockStatus(_response);
		});
	}

	protected processGetLockStatus(response: Response): Promise<boolean> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<boolean>(<any>null);
	}

	lockThread(data: CommentsThreadControllerPostData): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/commentsthread/lock";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processLockThread(_response);
		});
	}

	protected processLockThread(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	ping(): Promise<string> {
		let url_ = this.baseUrl + "/api/commentsthread";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPing(_response);
		});
	}

	protected processPing(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class ErrorClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	onGet(code: number | null | undefined): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/error?";
		if (code !== undefined && code !== null)
			url_ += "code=" + encodeURIComponent("" + code) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processOnGet(_response);
		});
	}

	protected processOnGet(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}
}

export class UsersClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	blockUser(data: BlockPostData): Promise<boolean> {
		let url_ = this.baseUrl + "/api/users/block";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processBlockUser(_response);
		});
	}

	protected processBlockUser(response: Response): Promise<boolean> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<boolean>(<any>null);
	}

	followUser(data: BlockPostData): Promise<boolean> {
		let url_ = this.baseUrl + "/api/users/follow";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processFollowUser(_response);
		});
	}

	protected processFollowUser(response: Response): Promise<boolean> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<boolean>(<any>null);
	}

	banUser(data: BanData): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/users/ban";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processBanUser(_response);
		});
	}

	protected processBanUser(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	muteUser(data: BanData): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/users/mute";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processMuteUser(_response);
		});
	}

	protected processMuteUser(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	manageRoles(data: RoleData): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/users/roles";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processManageRoles(_response);
		});
	}

	protected processManageRoles(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	ping(): Promise<string> {
		let url_ = this.baseUrl + "/api/users";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPing(_response);
		});
	}

	protected processPing(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class VotesClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getVotes(storyId: number): Promise<GetVotesResult> {
		let url_ = this.baseUrl + "/api/votes/{storyId}";
		if (storyId === undefined || storyId === null)
			throw new Error("The parameter 'storyId' must be defined.");
		url_ = url_.replace("{storyId}", encodeURIComponent("" + storyId));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetVotes(_response);
		});
	}

	protected processGetVotes(response: Response): Promise<GetVotesResult> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = GetVotesResult.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<GetVotesResult>(<any>null);
	}

	postVote(data: CreateVoteCommand): Promise<CreateVoteResult> {
		let url_ = this.baseUrl + "/api/votes";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostVote(_response);
		});
	}

	protected processPostVote(response: Response): Promise<CreateVoteResult> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CreateVoteResult.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<CreateVoteResult>(<any>null);
	}

	deleteVote(data: DeleteVoteCommand): Promise<DeleteVoteResult> {
		let url_ = this.baseUrl + "/api/votes";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "DELETE",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteVote(_response);
		});
	}

	protected processDeleteVote(response: Response): Promise<DeleteVoteResult> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = DeleteVoteResult.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<DeleteVoteResult>(<any>null);
	}
}

export class UserActivityClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	updateLastActive(): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/useractivity";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "HEAD",
			headers: {
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processUpdateLastActive(_response);
		});
	}

	protected processUpdateLastActive(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	ping(): Promise<string> {
		let url_ = this.baseUrl + "/api/useractivity";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPing(_response);
		});
	}

	protected processPing(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class TagsClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getAll(): Promise<TagDto[]> {
		let url_ = this.baseUrl + "/api/tags/all";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetAll(_response);
		});
	}

	protected processGetAll(response: Response): Promise<TagDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(TagDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<TagDto[]>(<any>null);
	}

	getTags(page: number | undefined, perPage: number | undefined): Promise<TagDto[]> {
		let url_ = this.baseUrl + "/api/tags?";
		if (page === null)
			throw new Error("The parameter 'page' cannot be null.");
		else if (page !== undefined)
			url_ += "Page=" + encodeURIComponent("" + page) + "&";
		if (perPage === null)
			throw new Error("The parameter 'perPage' cannot be null.");
		else if (perPage !== undefined)
			url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetTags(_response);
		});
	}

	protected processGetTags(response: Response): Promise<TagDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(TagDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<TagDto[]>(<any>null);
	}

	putTag(data: UpdateTagCommand): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/tags";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPutTag(_response);
		});
	}

	protected processPutTag(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	postTag(data: CreateTagCommand): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/tags";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostTag(_response);
		});
	}

	protected processPostTag(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	getTag(id: number): Promise<TagDto> {
		let url_ = this.baseUrl + "/api/tags/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetTag(_response);
		});
	}

	protected processGetTag(response: Response): Promise<TagDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = TagDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<TagDto>(<any>null);
	}

	deleteTag(id: number): Promise<number> {
		let url_ = this.baseUrl + "/api/tags/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteTag(_response);
		});
	}

	protected processDeleteTag(response: Response): Promise<number> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<number>(<any>null);
	}

	getStoryTags(id: number): Promise<TagDto[]> {
		let url_ = this.baseUrl + "/api/tags/story/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetStoryTags(_response);
		});
	}

	protected processGetStoryTags(response: Response): Promise<TagDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(TagDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<TagDto[]>(<any>null);
	}
}

export class SubscriptionsClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	isSubscribedToThread(threadId: number | undefined): Promise<boolean> {
		let url_ = this.baseUrl + "/api/subscriptions/thread?";
		if (threadId === null)
			throw new Error("The parameter 'threadId' cannot be null.");
		else if (threadId !== undefined)
			url_ += "ThreadId=" + encodeURIComponent("" + threadId) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processIsSubscribedToThread(_response);
		});
	}

	protected processIsSubscribedToThread(response: Response): Promise<boolean> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<boolean>(<any>null);
	}

	subscribeThread(data: SubscribeCommentsThreadCommand): Promise<boolean> {
		let url_ = this.baseUrl + "/api/subscriptions/thread";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processSubscribeThread(_response);
		});
	}

	protected processSubscribeThread(response: Response): Promise<boolean> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<boolean>(<any>null);
	}

	unsubscribeThread(data: UnsubscribeCommentsThreadCommand): Promise<boolean> {
		let url_ = this.baseUrl + "/api/subscriptions/thread";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "DELETE",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processUnsubscribeThread(_response);
		});
	}

	protected processUnsubscribeThread(response: Response): Promise<boolean> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<boolean>(<any>null);
	}

	ping(): Promise<string> {
		let url_ = this.baseUrl + "/api/subscriptions";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPing(_response);
		});
	}

	protected processPing(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class SignInClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getSignIn(name: string | null | undefined): Promise<GetSignInDataResult> {
		let url_ = this.baseUrl + "/api/signin?";
		if (name !== undefined && name !== null)
			url_ += "name=" + encodeURIComponent("" + name) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetSignIn(_response);
		});
	}

	protected processGetSignIn(response: Response): Promise<GetSignInDataResult> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = GetSignInDataResult.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<GetSignInDataResult>(<any>null);
	}
}

export class ShelvesClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getShelf(id: number): Promise<ShelfDto> {
		let url_ = this.baseUrl + "/api/shelves/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetShelf(_response);
		});
	}

	protected processGetShelf(response: Response): Promise<ShelfDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = ShelfDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<ShelfDto>(<any>null);
	}

	deleteShelf(id: number): Promise<number> {
		let url_ = this.baseUrl + "/api/shelves/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteShelf(_response);
		});
	}

	protected processDeleteShelf(response: Response): Promise<number> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<number>(<any>null);
	}

	getUserShelves(name: string | null, page: number | undefined): Promise<ShelfDto[]> {
		let url_ = this.baseUrl + "/api/shelves/{name}?";
		if (name === undefined || name === null)
			throw new Error("The parameter 'name' must be defined.");
		url_ = url_.replace("{name}", encodeURIComponent("" + name));
		if (page === null)
			throw new Error("The parameter 'page' cannot be null.");
		else if (page !== undefined)
			url_ += "page=" + encodeURIComponent("" + page) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUserShelves(_response);
		});
	}

	protected processGetUserShelves(response: Response): Promise<ShelfDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(ShelfDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<ShelfDto[]>(<any>null);
	}

	postShelf(data: CreateShelfCommand): Promise<ShelfDto> {
		let url_ = this.baseUrl + "/api/shelves";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostShelf(_response);
		});
	}

	protected processPostShelf(response: Response): Promise<ShelfDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = ShelfDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<ShelfDto>(<any>null);
	}

	putShelf(data: UpdateShelfCommand): Promise<ShelfDto> {
		let url_ = this.baseUrl + "/api/shelves";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPutShelf(_response);
		});
	}

	protected processPutShelf(response: Response): Promise<ShelfDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = ShelfDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<ShelfDto>(<any>null);
	}
}

export class ShelfStoriesClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getUserQuickShelves(storyId: number): Promise<ShelfDto[]> {
		let url_ = this.baseUrl + "/api/shelfstories/{storyId}/quick";
		if (storyId === undefined || storyId === null)
			throw new Error("The parameter 'storyId' must be defined.");
		url_ = url_.replace("{storyId}", encodeURIComponent("" + storyId));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUserQuickShelves(_response);
		});
	}

	protected processGetUserQuickShelves(response: Response): Promise<ShelfDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(ShelfDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<ShelfDto[]>(<any>null);
	}

	getUserShelvesPaginated(storyId: number, page: number | undefined): Promise<GetPaginatedUserShelvesResult[]> {
		let url_ = this.baseUrl + "/api/shelfstories/{storyId}?";
		if (storyId === undefined || storyId === null)
			throw new Error("The parameter 'storyId' must be defined.");
		url_ = url_.replace("{storyId}", encodeURIComponent("" + storyId));
		if (page === null)
			throw new Error("The parameter 'page' cannot be null.");
		else if (page !== undefined)
			url_ += "page=" + encodeURIComponent("" + page) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUserShelvesPaginated(_response);
		});
	}

	protected processGetUserShelvesPaginated(response: Response): Promise<GetPaginatedUserShelvesResult[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(GetPaginatedUserShelvesResult.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<GetPaginatedUserShelvesResult[]>(<any>null);
	}

	addToShelf(shelfId: number, storyId: number): Promise<AddBookToShelfResult> {
		let url_ = this.baseUrl + "/api/shelfstories/{shelfId}/{storyId}";
		if (shelfId === undefined || shelfId === null)
			throw new Error("The parameter 'shelfId' must be defined.");
		url_ = url_.replace("{shelfId}", encodeURIComponent("" + shelfId));
		if (storyId === undefined || storyId === null)
			throw new Error("The parameter 'storyId' must be defined.");
		url_ = url_.replace("{storyId}", encodeURIComponent("" + storyId));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "POST",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processAddToShelf(_response);
		});
	}

	protected processAddToShelf(response: Response): Promise<AddBookToShelfResult> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = AddBookToShelfResult.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<AddBookToShelfResult>(<any>null);
	}

	removeFromShelf(shelfId: number, storyId: number): Promise<RemoveBookFromShelfResult> {
		let url_ = this.baseUrl + "/api/shelfstories/{shelfId}/{storyId}";
		if (shelfId === undefined || shelfId === null)
			throw new Error("The parameter 'shelfId' must be defined.");
		url_ = url_.replace("{shelfId}", encodeURIComponent("" + shelfId));
		if (storyId === undefined || storyId === null)
			throw new Error("The parameter 'storyId' must be defined.");
		url_ = url_.replace("{storyId}", encodeURIComponent("" + storyId));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processRemoveFromShelf(_response);
		});
	}

	protected processRemoveFromShelf(response: Response): Promise<RemoveBookFromShelfResult> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = RemoveBookFromShelfResult.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<RemoveBookFromShelfResult>(<any>null);
	}

	ping(): Promise<string> {
		let url_ = this.baseUrl + "/api/shelfstories";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPing(_response);
		});
	}

	protected processPing(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class RolesClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getRoles(): Promise<RoleDto[]> {
		let url_ = this.baseUrl + "/api/roles";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetRoles(_response);
		});
	}

	protected processGetRoles(response: Response): Promise<RoleDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(RoleDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<RoleDto[]>(<any>null);
	}

	putRole(data: UpdateRoleCommand): Promise<RoleDto> {
		let url_ = this.baseUrl + "/api/roles";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPutRole(_response);
		});
	}

	protected processPutRole(response: Response): Promise<RoleDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = RoleDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<RoleDto>(<any>null);
	}

	postRole(data: CreateRoleCommand): Promise<RoleDto> {
		let url_ = this.baseUrl + "/api/roles";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostRole(_response);
		});
	}

	protected processPostRole(response: Response): Promise<RoleDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = RoleDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<RoleDto>(<any>null);
	}

	getRole(id: number): Promise<RoleDto> {
		let url_ = this.baseUrl + "/api/roles/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetRole(_response);
		});
	}

	protected processGetRole(response: Response): Promise<RoleDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = RoleDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<RoleDto>(<any>null);
	}

	deleteRole(id: number): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/roles/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteRole(_response);
		});
	}

	protected processDeleteRole(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}
}

export class ReportsClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	postReports(data: ReportContentCommand): Promise<number> {
		let url_ = this.baseUrl + "/api/reports";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostReports(_response);
		});
	}

	protected processPostReports(response: Response): Promise<number> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<number>(<any>null);
	}

	ping(): Promise<string> {
		let url_ = this.baseUrl + "/api/reports";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPing(_response);
		});
	}

	protected processPing(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class RatingsClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getRatings(): Promise<RatingApiDto[]> {
		let url_ = this.baseUrl + "/api/ratings";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetRatings(_response);
		});
	}

	protected processGetRatings(response: Response): Promise<RatingApiDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(RatingApiDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<RatingApiDto[]>(<any>null);
	}

	postRating(name: string | null | undefined, description: string | null | undefined, blacklistedByDefault: boolean | undefined, order: number | undefined, icon: FileParameter | null | undefined): Promise<RatingApiDto> {
		let url_ = this.baseUrl + "/api/ratings";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = new FormData();
		if (name !== null && name !== undefined)
			content_.append("Name", name.toString());
		if (description !== null && description !== undefined)
			content_.append("Description", description.toString());
		if (blacklistedByDefault === null || blacklistedByDefault === undefined)
			throw new Error("The parameter 'blacklistedByDefault' cannot be null.");
		else
			content_.append("BlacklistedByDefault", blacklistedByDefault.toString());
		if (order === null || order === undefined)
			throw new Error("The parameter 'order' cannot be null.");
		else
			content_.append("Order", order.toString());
		if (icon !== null && icon !== undefined)
			content_.append("Icon", icon.data, icon.fileName ? icon.fileName : "Icon");

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostRating(_response);
		});
	}

	protected processPostRating(response: Response): Promise<RatingApiDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = RatingApiDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<RatingApiDto>(<any>null);
	}

	putRating(id: number | undefined, name: string | null | undefined, description: string | null | undefined, blacklistedByDefault: boolean | undefined, order: number | undefined, icon: FileParameter | null | undefined): Promise<RatingApiDto> {
		let url_ = this.baseUrl + "/api/ratings";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = new FormData();
		if (id === null || id === undefined)
			throw new Error("The parameter 'id' cannot be null.");
		else
			content_.append("Id", id.toString());
		if (name !== null && name !== undefined)
			content_.append("Name", name.toString());
		if (description !== null && description !== undefined)
			content_.append("Description", description.toString());
		if (blacklistedByDefault === null || blacklistedByDefault === undefined)
			throw new Error("The parameter 'blacklistedByDefault' cannot be null.");
		else
			content_.append("BlacklistedByDefault", blacklistedByDefault.toString());
		if (order === null || order === undefined)
			throw new Error("The parameter 'order' cannot be null.");
		else
			content_.append("Order", order.toString());
		if (icon !== null && icon !== undefined)
			content_.append("Icon", icon.data, icon.fileName ? icon.fileName : "Icon");

		let options_ = <RequestInit>{
			body: content_,
			method: "PUT",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPutRating(_response);
		});
	}

	protected processPutRating(response: Response): Promise<RatingApiDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = RatingApiDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<RatingApiDto>(<any>null);
	}

	getRating(id: number): Promise<RatingApiDto> {
		let url_ = this.baseUrl + "/api/ratings/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetRating(_response);
		});
	}

	protected processGetRating(response: Response): Promise<RatingApiDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = RatingApiDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<RatingApiDto>(<any>null);
	}

	deleteRating(id: number): Promise<number> {
		let url_ = this.baseUrl + "/api/ratings/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteRating(_response);
		});
	}

	protected processDeleteRating(response: Response): Promise<number> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<number>(<any>null);
	}
}

export class QuotesClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getQuotes(): Promise<Quote[]> {
		let url_ = this.baseUrl + "/api/quotes";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetQuotes(_response);
		});
	}

	protected processGetQuotes(response: Response): Promise<Quote[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(Quote.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<Quote[]>(<any>null);
	}

	postQuote(q: CreateQuoteCommand): Promise<Quote> {
		let url_ = this.baseUrl + "/api/quotes";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(q);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostQuote(_response);
		});
	}

	protected processPostQuote(response: Response): Promise<Quote> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = Quote.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<Quote>(<any>null);
	}

	putQuote(q: UpdateQuoteCommand): Promise<Quote> {
		let url_ = this.baseUrl + "/api/quotes";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(q);

		let options_ = <RequestInit>{
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPutQuote(_response);
		});
	}

	protected processPutQuote(response: Response): Promise<Quote> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = Quote.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<Quote>(<any>null);
	}

	deleteQuote(q: DeleteQuoteCommand): Promise<Quote> {
		let url_ = this.baseUrl + "/api/quotes";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(q);

		let options_ = <RequestInit>{
			body: content_,
			method: "DELETE",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteQuote(_response);
		});
	}

	protected processDeleteQuote(response: Response): Promise<Quote> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = Quote.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<Quote>(<any>null);
	}

	getQuote(id: number): Promise<QuoteDto> {
		let url_ = this.baseUrl + "/api/quotes/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetQuote(_response);
		});
	}

	protected processGetQuote(response: Response): Promise<QuoteDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = QuoteDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<QuoteDto>(<any>null);
	}

	getRandomQuote(): Promise<QuoteDto> {
		let url_ = this.baseUrl + "/api/quotes/random";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetRandomQuote(_response);
		});
	}

	protected processGetRandomQuote(response: Response): Promise<QuoteDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = QuoteDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<QuoteDto>(<any>null);
	}

	postJson(): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/quotes/json";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "POST",
			headers: {
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostJson(_response);
		});
	}

	protected processPostJson(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}
}

export class NotificationsClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getUserNotifications(): Promise<GetUserNotificationsResult[]> {
		let url_ = this.baseUrl + "/api/notifications";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUserNotifications(_response);
		});
	}

	protected processGetUserNotifications(response: Response): Promise<GetUserNotificationsResult[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(GetUserNotificationsResult.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<GetUserNotificationsResult[]>(<any>null);
	}

	countUserNotifications(): Promise<number> {
		let url_ = this.baseUrl + "/api/notifications/count";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCountUserNotifications(_response);
		});
	}

	protected processCountUserNotifications(response: Response): Promise<number> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<number>(<any>null);
	}

	delete(id: number): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/notifications/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDelete(_response);
		});
	}

	protected processDelete(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}
}

export class InviteCodesClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getInviteCodes(): Promise<InviteCodeDto[]> {
		let url_ = this.baseUrl + "/api/invitecodes";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetInviteCodes(_response);
		});
	}

	protected processGetInviteCodes(response: Response): Promise<InviteCodeDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(InviteCodeDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<InviteCodeDto[]>(<any>null);
	}

	postInviteCode(): Promise<InviteCodeDto> {
		let url_ = this.baseUrl + "/api/invitecodes";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "POST",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostInviteCode(_response);
		});
	}

	protected processPostInviteCode(response: Response): Promise<InviteCodeDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = InviteCodeDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<InviteCodeDto>(<any>null);
	}

	getPaginatedInviteCodes(page: number | undefined, perPage: number | undefined): Promise<InviteCodeDto[]> {
		let url_ = this.baseUrl + "/api/invitecodes/paginated?";
		if (page === null)
			throw new Error("The parameter 'page' cannot be null.");
		else if (page !== undefined)
			url_ += "Page=" + encodeURIComponent("" + page) + "&";
		if (perPage === null)
			throw new Error("The parameter 'perPage' cannot be null.");
		else if (perPage !== undefined)
			url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetPaginatedInviteCodes(_response);
		});
	}

	protected processGetPaginatedInviteCodes(response: Response): Promise<InviteCodeDto[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(InviteCodeDto.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<InviteCodeDto[]>(<any>null);
	}

	postInviteCodeNoLimit(): Promise<InviteCodeDto> {
		let url_ = this.baseUrl + "/api/invitecodes/no-limit";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "POST",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostInviteCodeNoLimit(_response);
		});
	}

	protected processPostInviteCodeNoLimit(response: Response): Promise<InviteCodeDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = InviteCodeDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<InviteCodeDto>(<any>null);
	}

	deleteInviteCode(id: number): Promise<number> {
		let url_ = this.baseUrl + "/api/invitecodes/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteInviteCode(_response);
		});
	}

	protected processDeleteInviteCode(response: Response): Promise<number> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<number>(<any>null);
	}
}

export class FoldersClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getFoldersOfClub(id: number): Promise<GetFolderResult[]> {
		let url_ = this.baseUrl + "/api/folders/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetFoldersOfClub(_response);
		});
	}

	protected processGetFoldersOfClub(response: Response): Promise<GetFolderResult[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(GetFolderResult.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<GetFolderResult[]>(<any>null);
	}

	addStory(data: AddStoryToFolderCommand): Promise<FolderStory> {
		let url_ = this.baseUrl + "/api/folders/add-story";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processAddStory(_response);
		});
	}

	protected processAddStory(response: Response): Promise<FolderStory> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = FolderStory.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FolderStory>(<any>null);
	}

	ping(): Promise<string> {
		let url_ = this.baseUrl + "/api/folders";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPing(_response);
		});
	}

	protected processPing(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class FaqsClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getFaqs(): Promise<Faq[]> {
		let url_ = this.baseUrl + "/api/faqs";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetFaqs(_response);
		});
	}

	protected processGetFaqs(response: Response): Promise<Faq[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(Faq.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<Faq[]>(<any>null);
	}

	putFaq(data: UpdateFaqCommand): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/faqs";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPutFaq(_response);
		});
	}

	protected processPutFaq(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	postFaq(data: CreateFaqCommand): Promise<Faq> {
		let url_ = this.baseUrl + "/api/faqs";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostFaq(_response);
		});
	}

	protected processPostFaq(response: Response): Promise<Faq> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = Faq.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<Faq>(<any>null);
	}

	getFaq(id: number): Promise<Faq> {
		let url_ = this.baseUrl + "/api/faqs/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetFaq(_response);
		});
	}

	protected processGetFaq(response: Response): Promise<Faq> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = Faq.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<Faq>(<any>null);
	}

	deleteFaq(id: number): Promise<number> {
		let url_ = this.baseUrl + "/api/faqs/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteFaq(_response);
		});
	}

	protected processDeleteFaq(response: Response): Promise<number> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<number>(<any>null);
	}
}

export class ContentBlockClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	blockStory(data: CommandOfStory): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/contentblock/story";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processBlockStory(_response);
		});
	}

	protected processBlockStory(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	blockChapter(data: CommandOfChapter): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/contentblock/chapter";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processBlockChapter(_response);
		});
	}

	protected processBlockChapter(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	blockBlogpost(data: CommandOfBlogpost): Promise<FileResponse> {
		let url_ = this.baseUrl + "/api/contentblock/blogpost";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/octet-stream"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processBlockBlogpost(_response);
		});
	}

	protected processBlockBlogpost(response: Response): Promise<FileResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
			const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<FileResponse>(<any>null);
	}

	ping(): Promise<string> {
		let url_ = this.baseUrl + "/api/contentblock";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPing(_response);
		});
	}

	protected processPing(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class ClubsClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getUserClubs(): Promise<GetJoinedClubsResponse[]> {
		let url_ = this.baseUrl + "/api/clubs/user";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUserClubs(_response);
		});
	}

	protected processGetUserClubs(response: Response): Promise<GetJoinedClubsResponse[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(GetJoinedClubsResponse.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<GetJoinedClubsResponse[]>(<any>null);
	}

	getClubsWithStory(id: number): Promise<GetClubsWithStoryResult[]> {
		let url_ = this.baseUrl + "/api/clubs/story/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetClubsWithStory(_response);
		});
	}

	protected processGetClubsWithStory(response: Response): Promise<GetClubsWithStoryResult[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(GetClubsWithStoryResult.fromJS(item));
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<GetClubsWithStoryResult[]>(<any>null);
	}

	ping(): Promise<string> {
		let url_ = this.baseUrl + "/api/clubs";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPing(_response);
		});
	}

	protected processPing(response: Response): Promise<string> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<string>(<any>null);
	}
}

export class ClubJoinClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	checkMembershipStatus(club: number): Promise<boolean> {
		let url_ = this.baseUrl + "/api/clubjoin/{club}";
		if (club === undefined || club === null)
			throw new Error("The parameter 'club' must be defined.");
		url_ = url_.replace("{club}", encodeURIComponent("" + club));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCheckMembershipStatus(_response);
		});
	}

	protected processCheckMembershipStatus(response: Response): Promise<boolean> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<boolean>(<any>null);
	}

	joinClub(data: JoinClubCommand): Promise<boolean> {
		let url_ = this.baseUrl + "/api/clubjoin";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processJoinClub(_response);
		});
	}

	protected processJoinClub(response: Response): Promise<boolean> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<boolean>(<any>null);
	}

	leaveClub(data: LeaveClubCommand): Promise<boolean> {
		let url_ = this.baseUrl + "/api/clubjoin";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(data);

		let options_ = <RequestInit>{
			body: content_,
			method: "DELETE",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processLeaveClub(_response);
		});
	}

	protected processLeaveClub(response: Response): Promise<boolean> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 !== undefined ? resultData200 : <any>null;
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<boolean>(<any>null);
	}
}

export class ChaptersReadClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
	}

	getChaptersRead(story: number): Promise<number[]> {
		let url_ = this.baseUrl + "/api/chaptersread/{story}";
		if (story === undefined || story === null)
			throw new Error("The parameter 'story' must be defined.");
		url_ = url_.replace("{story}", encodeURIComponent("" + story));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetChaptersRead(_response);
		});
	}

	protected processGetChaptersRead(response: Response): Promise<number[]> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(item);
				}
				else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<number[]>(<any>null);
	}

	postChaptersRead(post: MarkChapterAsReadCommand): Promise<MarkChapterAsReadResponse> {
		let url_ = this.baseUrl + "/api/chaptersread";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(post);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processPostChaptersRead(_response);
		});
	}

	protected processPostChaptersRead(response: Response): Promise<MarkChapterAsReadResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = MarkChapterAsReadResponse.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<MarkChapterAsReadResponse>(<any>null);
	}

	deleteChaptersRead(post: MarkChapterAsUnreadCommand): Promise<MarkChapterAsUnreadResponse> {
		let url_ = this.baseUrl + "/api/chaptersread";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(post);

		let options_ = <RequestInit>{
			body: content_,
			method: "DELETE",
			headers: {
				"Content-Type": "application/json",
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteChaptersRead(_response);
		});
	}

	protected processDeleteChaptersRead(response: Response): Promise<MarkChapterAsUnreadResponse> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = MarkChapterAsUnreadResponse.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<MarkChapterAsUnreadResponse>(<any>null);
	}
}

export class PaginationResultOfCommentDto implements IPaginationResultOfCommentDto {
	elements?: CommentDto[] | undefined;
	total?: number;
	perPage?: number;
	pages?: number;
	page?: number;

	constructor(data?: IPaginationResultOfCommentDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			if (Array.isArray(_data["elements"])) {
				this.elements = [] as any;
				for (let item of _data["elements"])
					this.elements!.push(CommentDto.fromJS(item));
			}
			this.total = _data["total"];
			this.perPage = _data["perPage"];
			this.pages = _data["pages"];
			this.page = _data["page"];
		}
	}

	static fromJS(data: any): PaginationResultOfCommentDto {
		data = typeof data === 'object' ? data : {};
		let result = new PaginationResultOfCommentDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		if (Array.isArray(this.elements)) {
			data["elements"] = [];
			for (let item of this.elements)
				data["elements"].push(item.toJSON());
		}
		data["total"] = this.total;
		data["perPage"] = this.perPage;
		data["pages"] = this.pages;
		data["page"] = this.page;
		return data;
	}
}

export interface IPaginationResultOfCommentDto {
	elements?: CommentDto[] | undefined;
	total?: number;
	perPage?: number;
	pages?: number;
	page?: number;
}

export class CommentDto implements ICommentDto {
	id?: number;
	author?: UserSimpleDto | undefined;
	dateTime?: Date;
	lastEdit?: Date | undefined;
	editCount?: number;
	owned?: boolean;
	body?: string | undefined;
	deletedBy?: EDeletedBy | undefined;
	isBlocked?: boolean;

	constructor(data?: ICommentDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.author = _data["author"] ? UserSimpleDto.fromJS(_data["author"]) : <any>undefined;
			this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
			this.lastEdit = _data["lastEdit"] ? new Date(_data["lastEdit"].toString()) : <any>undefined;
			this.editCount = _data["editCount"];
			this.owned = _data["owned"];
			this.body = _data["body"];
			this.deletedBy = _data["deletedBy"];
			this.isBlocked = _data["isBlocked"];
		}
	}

	static fromJS(data: any): CommentDto {
		data = typeof data === 'object' ? data : {};
		let result = new CommentDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["author"] = this.author ? this.author.toJSON() : <any>undefined;
		data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
		data["lastEdit"] = this.lastEdit ? this.lastEdit.toISOString() : <any>undefined;
		data["editCount"] = this.editCount;
		data["owned"] = this.owned;
		data["body"] = this.body;
		data["deletedBy"] = this.deletedBy;
		data["isBlocked"] = this.isBlocked;
		return data;
	}
}

export interface ICommentDto {
	id?: number;
	author?: UserSimpleDto | undefined;
	dateTime?: Date;
	lastEdit?: Date | undefined;
	editCount?: number;
	owned?: boolean;
	body?: string | undefined;
	deletedBy?: EDeletedBy | undefined;
	isBlocked?: boolean;
}

export class UserSimpleDto implements IUserSimpleDto {
	userName?: string | undefined;
	avatar?: string | undefined;
	title?: string | undefined;
	roles?: RoleDto[] | undefined;

	constructor(data?: IUserSimpleDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.userName = _data["userName"];
			this.avatar = _data["avatar"];
			this.title = _data["title"];
			if (Array.isArray(_data["roles"])) {
				this.roles = [] as any;
				for (let item of _data["roles"])
					this.roles!.push(RoleDto.fromJS(item));
			}
		}
	}

	static fromJS(data: any): UserSimpleDto {
		data = typeof data === 'object' ? data : {};
		let result = new UserSimpleDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["userName"] = this.userName;
		data["avatar"] = this.avatar;
		data["title"] = this.title;
		if (Array.isArray(this.roles)) {
			data["roles"] = [];
			for (let item of this.roles)
				data["roles"].push(item.toJSON());
		}
		return data;
	}
}

export interface IUserSimpleDto {
	userName?: string | undefined;
	avatar?: string | undefined;
	title?: string | undefined;
	roles?: RoleDto[] | undefined;
}

export class RoleDto implements IRoleDto {
	id?: number;
	name?: string | undefined;
	color?: string | undefined;
	isStaff?: boolean;
	order?: number;

	constructor(data?: IRoleDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.color = _data["color"];
			this.isStaff = _data["isStaff"];
			this.order = _data["order"];
		}
	}

	static fromJS(data: any): RoleDto {
		data = typeof data === 'object' ? data : {};
		let result = new RoleDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["color"] = this.color;
		data["isStaff"] = this.isStaff;
		data["order"] = this.order;
		return data;
	}
}

export interface IRoleDto {
	id?: number;
	name?: string | undefined;
	color?: string | undefined;
	isStaff?: boolean;
	order?: number;
}

export enum EDeletedBy {
	User = "User",
	Staff = "Staff",
}

export class CommentRevisionDto implements ICommentRevisionDto {
	editTime?: Date;
	body?: string | undefined;

	constructor(data?: ICommentRevisionDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.editTime = _data["editTime"] ? new Date(_data["editTime"].toString()) : <any>undefined;
			this.body = _data["body"];
		}
	}

	static fromJS(data: any): CommentRevisionDto {
		data = typeof data === 'object' ? data : {};
		let result = new CommentRevisionDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["editTime"] = this.editTime ? this.editTime.toISOString() : <any>undefined;
		data["body"] = this.body;
		return data;
	}
}

export interface ICommentRevisionDto {
	editTime?: Date;
	body?: string | undefined;
}

export class CommentsControllerPatchData implements ICommentsControllerPatchData {
	body?: string | undefined;
	id?: number;

	constructor(data?: ICommentsControllerPatchData) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.body = _data["body"];
			this.id = _data["id"];
		}
	}

	static fromJS(data: any): CommentsControllerPatchData {
		data = typeof data === 'object' ? data : {};
		let result = new CommentsControllerPatchData();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["body"] = this.body;
		data["id"] = this.id;
		return data;
	}
}

export interface ICommentsControllerPatchData {
	body?: string | undefined;
	id?: number;
}

export class CommentsControllerPostData implements ICommentsControllerPostData {
	body?: string | undefined;
	thread?: number;

	constructor(data?: ICommentsControllerPostData) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.body = _data["body"];
			this.thread = _data["thread"];
		}
	}

	static fromJS(data: any): CommentsControllerPostData {
		data = typeof data === 'object' ? data : {};
		let result = new CommentsControllerPostData();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["body"] = this.body;
		data["thread"] = this.thread;
		return data;
	}
}

export interface ICommentsControllerPostData {
	body?: string | undefined;
	thread?: number;
}

export class CommentsThreadControllerPermissionsResult implements ICommentsThreadControllerPermissionsResult {
	isSiteModerator?: boolean;
	isClubModerator?: boolean;
	isAllowed?: boolean;

	constructor(data?: ICommentsThreadControllerPermissionsResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.isSiteModerator = _data["isSiteModerator"];
			this.isClubModerator = _data["isClubModerator"];
			this.isAllowed = _data["isAllowed"];
		}
	}

	static fromJS(data: any): CommentsThreadControllerPermissionsResult {
		data = typeof data === 'object' ? data : {};
		let result = new CommentsThreadControllerPermissionsResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["isSiteModerator"] = this.isSiteModerator;
		data["isClubModerator"] = this.isClubModerator;
		data["isAllowed"] = this.isAllowed;
		return data;
	}
}

export interface ICommentsThreadControllerPermissionsResult {
	isSiteModerator?: boolean;
	isClubModerator?: boolean;
	isAllowed?: boolean;
}

export class CommentsThreadControllerPostData implements ICommentsThreadControllerPostData {
	id?: number;

	constructor(data?: ICommentsThreadControllerPostData) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
		}
	}

	static fromJS(data: any): CommentsThreadControllerPostData {
		data = typeof data === 'object' ? data : {};
		let result = new CommentsThreadControllerPostData();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		return data;
	}
}

export interface ICommentsThreadControllerPostData {
	id?: number;
}

export class BlockPostData implements IBlockPostData {
	name?: string | undefined;

	constructor(data?: IBlockPostData) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.name = _data["name"];
		}
	}

	static fromJS(data: any): BlockPostData {
		data = typeof data === 'object' ? data : {};
		let result = new BlockPostData();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		return data;
	}
}

export interface IBlockPostData {
	name?: string | undefined;
}

export class BanData implements IBanData {
	userId?: number;
	days?: number | undefined;

	constructor(data?: IBanData) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.userId = _data["userId"];
			this.days = _data["days"];
		}
	}

	static fromJS(data: any): BanData {
		data = typeof data === 'object' ? data : {};
		let result = new BanData();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["userId"] = this.userId;
		data["days"] = this.days;
		return data;
	}
}

export interface IBanData {
	userId?: number;
	days?: number | undefined;
}

export class RoleData implements IRoleData {
	userId?: number;
	roles?: number[] | undefined;

	constructor(data?: IRoleData) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.userId = _data["userId"];
			if (Array.isArray(_data["roles"])) {
				this.roles = [] as any;
				for (let item of _data["roles"])
					this.roles!.push(item);
			}
		}
	}

	static fromJS(data: any): RoleData {
		data = typeof data === 'object' ? data : {};
		let result = new RoleData();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["userId"] = this.userId;
		if (Array.isArray(this.roles)) {
			data["roles"] = [];
			for (let item of this.roles)
				data["roles"].push(item);
		}
		return data;
	}
}

export interface IRoleData {
	userId?: number;
	roles?: number[] | undefined;
}

export class GetVotesResult implements IGetVotesResult {
	count?: number;
	didVote?: boolean;

	constructor(data?: IGetVotesResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.count = _data["count"];
			this.didVote = _data["didVote"];
		}
	}

	static fromJS(data: any): GetVotesResult {
		data = typeof data === 'object' ? data : {};
		let result = new GetVotesResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["count"] = this.count;
		data["didVote"] = this.didVote;
		return data;
	}
}

export interface IGetVotesResult {
	count?: number;
	didVote?: boolean;
}

export class CreateVoteResult implements ICreateVoteResult {
	didVote?: boolean;
	count?: number | undefined;

	constructor(data?: ICreateVoteResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.didVote = _data["didVote"];
			this.count = _data["count"];
		}
	}

	static fromJS(data: any): CreateVoteResult {
		data = typeof data === 'object' ? data : {};
		let result = new CreateVoteResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["didVote"] = this.didVote;
		data["count"] = this.count;
		return data;
	}
}

export interface ICreateVoteResult {
	didVote?: boolean;
	count?: number | undefined;
}

export class CreateVoteCommand implements ICreateVoteCommand {
	storyId?: number;

	constructor(data?: ICreateVoteCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.storyId = _data["storyId"];
		}
	}

	static fromJS(data: any): CreateVoteCommand {
		data = typeof data === 'object' ? data : {};
		let result = new CreateVoteCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["storyId"] = this.storyId;
		return data;
	}
}

export interface ICreateVoteCommand {
	storyId?: number;
}

export class DeleteVoteResult implements IDeleteVoteResult {
	didVote?: boolean;
	count?: number | undefined;

	constructor(data?: IDeleteVoteResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.didVote = _data["didVote"];
			this.count = _data["count"];
		}
	}

	static fromJS(data: any): DeleteVoteResult {
		data = typeof data === 'object' ? data : {};
		let result = new DeleteVoteResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["didVote"] = this.didVote;
		data["count"] = this.count;
		return data;
	}
}

export interface IDeleteVoteResult {
	didVote?: boolean;
	count?: number | undefined;
}

export class DeleteVoteCommand implements IDeleteVoteCommand {
	storyId?: number;

	constructor(data?: IDeleteVoteCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.storyId = _data["storyId"];
		}
	}

	static fromJS(data: any): DeleteVoteCommand {
		data = typeof data === 'object' ? data : {};
		let result = new DeleteVoteCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["storyId"] = this.storyId;
		return data;
	}
}

export interface IDeleteVoteCommand {
	storyId?: number;
}

export class TagDto implements ITagDto {
	id?: number;
	name?: string | undefined;
	slug?: string | undefined;
	description?: string | undefined;
	namespace?: ETagNamespace | undefined;
	namespaceColor?: string | undefined;
	namespaceId?: number | undefined;

	constructor(data?: ITagDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.slug = _data["slug"];
			this.description = _data["description"];
			this.namespace = _data["namespace"];
			this.namespaceColor = _data["namespaceColor"];
			this.namespaceId = _data["namespaceId"];
		}
	}

	static fromJS(data: any): TagDto {
		data = typeof data === 'object' ? data : {};
		let result = new TagDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["slug"] = this.slug;
		data["description"] = this.description;
		data["namespace"] = this.namespace;
		data["namespaceColor"] = this.namespaceColor;
		data["namespaceId"] = this.namespaceId;
		return data;
	}
}

export interface ITagDto {
	id?: number;
	name?: string | undefined;
	slug?: string | undefined;
	description?: string | undefined;
	namespace?: ETagNamespace | undefined;
	namespaceColor?: string | undefined;
	namespaceId?: number | undefined;
}

export enum ETagNamespace {
	ContentWarning = "ContentWarning",
	Genre = "Genre",
	Franchise = "Franchise",
}

export class UpdateTagCommand implements IUpdateTagCommand {
	id?: number;
	name?: string | undefined;
	description?: string | undefined;
	namespace?: ETagNamespace | undefined;

	constructor(data?: IUpdateTagCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.description = _data["description"];
			this.namespace = _data["namespace"];
		}
	}

	static fromJS(data: any): UpdateTagCommand {
		data = typeof data === 'object' ? data : {};
		let result = new UpdateTagCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["description"] = this.description;
		data["namespace"] = this.namespace;
		return data;
	}
}

export interface IUpdateTagCommand {
	id?: number;
	name?: string | undefined;
	description?: string | undefined;
	namespace?: ETagNamespace | undefined;
}

export class CreateTagCommand implements ICreateTagCommand {
	name?: string | undefined;
	description?: string | undefined;
	namespace?: ETagNamespace | undefined;

	constructor(data?: ICreateTagCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.name = _data["name"];
			this.description = _data["description"];
			this.namespace = _data["namespace"];
		}
	}

	static fromJS(data: any): CreateTagCommand {
		data = typeof data === 'object' ? data : {};
		let result = new CreateTagCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		data["description"] = this.description;
		data["namespace"] = this.namespace;
		return data;
	}
}

export interface ICreateTagCommand {
	name?: string | undefined;
	description?: string | undefined;
	namespace?: ETagNamespace | undefined;
}

export class SubscribeCommentsThreadCommand implements ISubscribeCommentsThreadCommand {
	threadId?: number;

	constructor(data?: ISubscribeCommentsThreadCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.threadId = _data["threadId"];
		}
	}

	static fromJS(data: any): SubscribeCommentsThreadCommand {
		data = typeof data === 'object' ? data : {};
		let result = new SubscribeCommentsThreadCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["threadId"] = this.threadId;
		return data;
	}
}

export interface ISubscribeCommentsThreadCommand {
	threadId?: number;
}

export class UnsubscribeCommentsThreadCommand implements IUnsubscribeCommentsThreadCommand {
	threadId?: number;

	constructor(data?: IUnsubscribeCommentsThreadCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.threadId = _data["threadId"];
		}
	}

	static fromJS(data: any): UnsubscribeCommentsThreadCommand {
		data = typeof data === 'object' ? data : {};
		let result = new UnsubscribeCommentsThreadCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["threadId"] = this.threadId;
		return data;
	}
}

export interface IUnsubscribeCommentsThreadCommand {
	threadId?: number;
}

export class GetSignInDataResult implements IGetSignInDataResult {
	avatar?: string | undefined;
	title?: string | undefined;

	constructor(data?: IGetSignInDataResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.avatar = _data["avatar"];
			this.title = _data["title"];
		}
	}

	static fromJS(data: any): GetSignInDataResult {
		data = typeof data === 'object' ? data : {};
		let result = new GetSignInDataResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["avatar"] = this.avatar;
		data["title"] = this.title;
		return data;
	}
}

export interface IGetSignInDataResult {
	avatar?: string | undefined;
	title?: string | undefined;
}

export class ShelfDto implements IShelfDto {
	id?: number;
	name?: string | undefined;
	description?: string | undefined;
	isDefault?: boolean;
	isPublic?: boolean;
	isQuickAdd?: boolean;
	trackUpdates?: boolean;
	color?: string | undefined;
	storiesCount?: number;
	iconName?: string | undefined;
	iconId?: number | undefined;

	constructor(data?: IShelfDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.description = _data["description"];
			this.isDefault = _data["isDefault"];
			this.isPublic = _data["isPublic"];
			this.isQuickAdd = _data["isQuickAdd"];
			this.trackUpdates = _data["trackUpdates"];
			this.color = _data["color"];
			this.storiesCount = _data["storiesCount"];
			this.iconName = _data["iconName"];
			this.iconId = _data["iconId"];
		}
	}

	static fromJS(data: any): ShelfDto {
		data = typeof data === 'object' ? data : {};
		let result = new ShelfDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["description"] = this.description;
		data["isDefault"] = this.isDefault;
		data["isPublic"] = this.isPublic;
		data["isQuickAdd"] = this.isQuickAdd;
		data["trackUpdates"] = this.trackUpdates;
		data["color"] = this.color;
		data["storiesCount"] = this.storiesCount;
		data["iconName"] = this.iconName;
		data["iconId"] = this.iconId;
		return data;
	}
}

export interface IShelfDto {
	id?: number;
	name?: string | undefined;
	description?: string | undefined;
	isDefault?: boolean;
	isPublic?: boolean;
	isQuickAdd?: boolean;
	trackUpdates?: boolean;
	color?: string | undefined;
	storiesCount?: number;
	iconName?: string | undefined;
	iconId?: number | undefined;
}

export class CreateShelfCommand implements ICreateShelfCommand {
	name?: string | undefined;
	description?: string | undefined;
	isQuickAdd?: boolean;
	isPublic?: boolean;
	trackUpdates?: boolean;
	color?: string | undefined;
	icon?: number;

	constructor(data?: ICreateShelfCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.name = _data["name"];
			this.description = _data["description"];
			this.isQuickAdd = _data["isQuickAdd"];
			this.isPublic = _data["isPublic"];
			this.trackUpdates = _data["trackUpdates"];
			this.color = _data["color"];
			this.icon = _data["icon"];
		}
	}

	static fromJS(data: any): CreateShelfCommand {
		data = typeof data === 'object' ? data : {};
		let result = new CreateShelfCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		data["description"] = this.description;
		data["isQuickAdd"] = this.isQuickAdd;
		data["isPublic"] = this.isPublic;
		data["trackUpdates"] = this.trackUpdates;
		data["color"] = this.color;
		data["icon"] = this.icon;
		return data;
	}
}

export interface ICreateShelfCommand {
	name?: string | undefined;
	description?: string | undefined;
	isQuickAdd?: boolean;
	isPublic?: boolean;
	trackUpdates?: boolean;
	color?: string | undefined;
	icon?: number;
}

export class UpdateShelfCommand implements IUpdateShelfCommand {
	id?: number;
	name?: string | undefined;
	description?: string | undefined;
	isQuickAdd?: boolean;
	isPublic?: boolean;
	trackUpdates?: boolean;
	color?: string | undefined;
	icon?: number;

	constructor(data?: IUpdateShelfCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.description = _data["description"];
			this.isQuickAdd = _data["isQuickAdd"];
			this.isPublic = _data["isPublic"];
			this.trackUpdates = _data["trackUpdates"];
			this.color = _data["color"];
			this.icon = _data["icon"];
		}
	}

	static fromJS(data: any): UpdateShelfCommand {
		data = typeof data === 'object' ? data : {};
		let result = new UpdateShelfCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["description"] = this.description;
		data["isQuickAdd"] = this.isQuickAdd;
		data["isPublic"] = this.isPublic;
		data["trackUpdates"] = this.trackUpdates;
		data["color"] = this.color;
		data["icon"] = this.icon;
		return data;
	}
}

export interface IUpdateShelfCommand {
	id?: number;
	name?: string | undefined;
	description?: string | undefined;
	isQuickAdd?: boolean;
	isPublic?: boolean;
	trackUpdates?: boolean;
	color?: string | undefined;
	icon?: number;
}

export class GetPaginatedUserShelvesResult implements IGetPaginatedUserShelvesResult {
	id?: number;
	name?: string | undefined;
	color?: string | undefined;
	iconName?: string | undefined;
	doesContainBook?: boolean;

	constructor(data?: IGetPaginatedUserShelvesResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.color = _data["color"];
			this.iconName = _data["iconName"];
			this.doesContainBook = _data["doesContainBook"];
		}
	}

	static fromJS(data: any): GetPaginatedUserShelvesResult {
		data = typeof data === 'object' ? data : {};
		let result = new GetPaginatedUserShelvesResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["color"] = this.color;
		data["iconName"] = this.iconName;
		data["doesContainBook"] = this.doesContainBook;
		return data;
	}
}

export interface IGetPaginatedUserShelvesResult {
	id?: number;
	name?: string | undefined;
	color?: string | undefined;
	iconName?: string | undefined;
	doesContainBook?: boolean;
}

export class AddBookToShelfResult implements IAddBookToShelfResult {
	shelfId?: number;
	storyId?: number;

	constructor(data?: IAddBookToShelfResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.shelfId = _data["shelfId"];
			this.storyId = _data["storyId"];
		}
	}

	static fromJS(data: any): AddBookToShelfResult {
		data = typeof data === 'object' ? data : {};
		let result = new AddBookToShelfResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["shelfId"] = this.shelfId;
		data["storyId"] = this.storyId;
		return data;
	}
}

export interface IAddBookToShelfResult {
	shelfId?: number;
	storyId?: number;
}

export class RemoveBookFromShelfResult implements IRemoveBookFromShelfResult {
	shelfId?: number;
	storyId?: number;

	constructor(data?: IRemoveBookFromShelfResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.shelfId = _data["shelfId"];
			this.storyId = _data["storyId"];
		}
	}

	static fromJS(data: any): RemoveBookFromShelfResult {
		data = typeof data === 'object' ? data : {};
		let result = new RemoveBookFromShelfResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["shelfId"] = this.shelfId;
		data["storyId"] = this.storyId;
		return data;
	}
}

export interface IRemoveBookFromShelfResult {
	shelfId?: number;
	storyId?: number;
}

export class UpdateRoleCommand implements IUpdateRoleCommand {
	id?: number;
	name?: string | undefined;
	isStaff?: boolean;
	color?: string | undefined;
	order?: number | undefined;

	constructor(data?: IUpdateRoleCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.isStaff = _data["isStaff"];
			this.color = _data["color"];
			this.order = _data["order"];
		}
	}

	static fromJS(data: any): UpdateRoleCommand {
		data = typeof data === 'object' ? data : {};
		let result = new UpdateRoleCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["isStaff"] = this.isStaff;
		data["color"] = this.color;
		data["order"] = this.order;
		return data;
	}
}

export interface IUpdateRoleCommand {
	id?: number;
	name?: string | undefined;
	isStaff?: boolean;
	color?: string | undefined;
	order?: number | undefined;
}

export class CreateRoleCommand implements ICreateRoleCommand {
	name?: string | undefined;
	isStaff?: boolean;
	color?: string | undefined;
	order?: number | undefined;

	constructor(data?: ICreateRoleCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.name = _data["name"];
			this.isStaff = _data["isStaff"];
			this.color = _data["color"];
			this.order = _data["order"];
		}
	}

	static fromJS(data: any): CreateRoleCommand {
		data = typeof data === 'object' ? data : {};
		let result = new CreateRoleCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		data["isStaff"] = this.isStaff;
		data["color"] = this.color;
		data["order"] = this.order;
		return data;
	}
}

export interface ICreateRoleCommand {
	name?: string | undefined;
	isStaff?: boolean;
	color?: string | undefined;
	order?: number | undefined;
}

export class ReportContentCommand implements IReportContentCommand {
	itemId?: number;
	reason?: string | undefined;
	itemType?: EReportableContentTypes;

	constructor(data?: IReportContentCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.itemId = _data["itemId"];
			this.reason = _data["reason"];
			this.itemType = _data["itemType"];
		}
	}

	static fromJS(data: any): ReportContentCommand {
		data = typeof data === 'object' ? data : {};
		let result = new ReportContentCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["itemId"] = this.itemId;
		data["reason"] = this.reason;
		data["itemType"] = this.itemType;
		return data;
	}
}

export interface IReportContentCommand {
	itemId?: number;
	reason?: string | undefined;
	itemType?: EReportableContentTypes;
}

export enum EReportableContentTypes {
	Comment = "Comment",
	User = "User",
	Story = "Story",
	Chapter = "Chapter",
	Blogpost = "Blogpost",
	Club = "Club",
}

export class RatingApiDto implements IRatingApiDto {
	id?: number;
	name?: string | undefined;
	description?: string | undefined;
	order?: number;
	icon?: string | undefined;
	blacklistedByDefault?: boolean;

	constructor(data?: IRatingApiDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.description = _data["description"];
			this.order = _data["order"];
			this.icon = _data["icon"];
			this.blacklistedByDefault = _data["blacklistedByDefault"];
		}
	}

	static fromJS(data: any): RatingApiDto {
		data = typeof data === 'object' ? data : {};
		let result = new RatingApiDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["description"] = this.description;
		data["order"] = this.order;
		data["icon"] = this.icon;
		data["blacklistedByDefault"] = this.blacklistedByDefault;
		return data;
	}
}

export interface IRatingApiDto {
	id?: number;
	name?: string | undefined;
	description?: string | undefined;
	order?: number;
	icon?: string | undefined;
	blacklistedByDefault?: boolean;
}

export abstract class BaseModel implements IBaseModel {
	id!: number;

	constructor(data?: IBaseModel) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
		}
	}

	static fromJS(data: any): BaseModel {
		data = typeof data === 'object' ? data : {};
		throw new Error("The abstract class 'BaseModel' cannot be instantiated.");
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		return data;
	}
}

export interface IBaseModel {
	id: number;
}

export class Quote extends BaseModel implements IQuote {
	body?: string | undefined;
	author?: string | undefined;

	constructor(data?: IQuote) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.body = _data["body"];
			this.author = _data["author"];
		}
	}

	static fromJS(data: any): Quote {
		data = typeof data === 'object' ? data : {};
		let result = new Quote();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["body"] = this.body;
		data["author"] = this.author;
		super.toJSON(data);
		return data;
	}
}

export interface IQuote extends IBaseModel {
	body?: string | undefined;
	author?: string | undefined;
}

export class QuoteDto implements IQuoteDto {
	body?: string | undefined;
	author?: string | undefined;

	constructor(data?: IQuoteDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.body = _data["body"];
			this.author = _data["author"];
		}
	}

	static fromJS(data: any): QuoteDto {
		data = typeof data === 'object' ? data : {};
		let result = new QuoteDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["body"] = this.body;
		data["author"] = this.author;
		return data;
	}
}

export interface IQuoteDto {
	body?: string | undefined;
	author?: string | undefined;
}

export class CreateQuoteCommand implements ICreateQuoteCommand {
	body?: string | undefined;
	author?: string | undefined;

	constructor(data?: ICreateQuoteCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.body = _data["body"];
			this.author = _data["author"];
		}
	}

	static fromJS(data: any): CreateQuoteCommand {
		data = typeof data === 'object' ? data : {};
		let result = new CreateQuoteCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["body"] = this.body;
		data["author"] = this.author;
		return data;
	}
}

export interface ICreateQuoteCommand {
	body?: string | undefined;
	author?: string | undefined;
}

export class UpdateQuoteCommand implements IUpdateQuoteCommand {
	id?: number;
	body?: string | undefined;
	author?: string | undefined;

	constructor(data?: IUpdateQuoteCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.body = _data["body"];
			this.author = _data["author"];
		}
	}

	static fromJS(data: any): UpdateQuoteCommand {
		data = typeof data === 'object' ? data : {};
		let result = new UpdateQuoteCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["body"] = this.body;
		data["author"] = this.author;
		return data;
	}
}

export interface IUpdateQuoteCommand {
	id?: number;
	body?: string | undefined;
	author?: string | undefined;
}

export class DeleteQuoteCommand implements IDeleteQuoteCommand {
	id?: number;

	constructor(data?: IDeleteQuoteCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
		}
	}

	static fromJS(data: any): DeleteQuoteCommand {
		data = typeof data === 'object' ? data : {};
		let result = new DeleteQuoteCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		return data;
	}
}

export interface IDeleteQuoteCommand {
	id?: number;
}

export class GetUserNotificationsResult implements IGetUserNotificationsResult {
	id?: number;
	body?: string | undefined;
	url?: string | undefined;
	dateTime?: Date;
	event?: ENotificationEvent;
	message?: string | undefined;

	constructor(data?: IGetUserNotificationsResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.body = _data["body"];
			this.url = _data["url"];
			this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
			this.event = _data["event"];
			this.message = _data["message"];
		}
	}

	static fromJS(data: any): GetUserNotificationsResult {
		data = typeof data === 'object' ? data : {};
		let result = new GetUserNotificationsResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["body"] = this.body;
		data["url"] = this.url;
		data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
		data["event"] = this.event;
		data["message"] = this.message;
		return data;
	}
}

export interface IGetUserNotificationsResult {
	id?: number;
	body?: string | undefined;
	url?: string | undefined;
	dateTime?: Date;
	event?: ENotificationEvent;
	message?: string | undefined;
}

export enum ENotificationEvent {
	System = "System",
	WatchedStoryUpdated = "WatchedStoryUpdated",
	WatchedThreadNewComment = "WatchedThreadNewComment",
	FollowedAuthorNewBlogpost = "FollowedAuthorNewBlogpost",
	FollowedAuthorNewStory = "FollowedAuthorNewStory",
	CommentReply = "CommentReply",
}

export class InviteCodeDto implements IInviteCodeDto {
	id?: number;
	code?: string | undefined;
	normalizedCode?: string | undefined;
	usedByUserName?: string | undefined;
	issuedByUserName?: string | undefined;
	issueDate?: Date;
	usedDate?: Date | undefined;

	constructor(data?: IInviteCodeDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.code = _data["code"];
			this.normalizedCode = _data["normalizedCode"];
			this.usedByUserName = _data["usedByUserName"];
			this.issuedByUserName = _data["issuedByUserName"];
			this.issueDate = _data["issueDate"] ? new Date(_data["issueDate"].toString()) : <any>undefined;
			this.usedDate = _data["usedDate"] ? new Date(_data["usedDate"].toString()) : <any>undefined;
		}
	}

	static fromJS(data: any): InviteCodeDto {
		data = typeof data === 'object' ? data : {};
		let result = new InviteCodeDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["code"] = this.code;
		data["normalizedCode"] = this.normalizedCode;
		data["usedByUserName"] = this.usedByUserName;
		data["issuedByUserName"] = this.issuedByUserName;
		data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
		data["usedDate"] = this.usedDate ? this.usedDate.toISOString() : <any>undefined;
		return data;
	}
}

export interface IInviteCodeDto {
	id?: number;
	code?: string | undefined;
	normalizedCode?: string | undefined;
	usedByUserName?: string | undefined;
	issuedByUserName?: string | undefined;
	issueDate?: Date;
	usedDate?: Date | undefined;
}

export class GetFolderResult implements IGetFolderResult {
	id?: number;
	name?: string | undefined;
	slug?: string | undefined;
	parentFolderId?: number | undefined;
	canAdd?: boolean;

	constructor(data?: IGetFolderResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.slug = _data["slug"];
			this.parentFolderId = _data["parentFolderId"];
			this.canAdd = _data["canAdd"];
		}
	}

	static fromJS(data: any): GetFolderResult {
		data = typeof data === 'object' ? data : {};
		let result = new GetFolderResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["slug"] = this.slug;
		data["parentFolderId"] = this.parentFolderId;
		data["canAdd"] = this.canAdd;
		return data;
	}
}

export interface IGetFolderResult {
	id?: number;
	name?: string | undefined;
	slug?: string | undefined;
	parentFolderId?: number | undefined;
	canAdd?: boolean;
}

export class FolderStory implements IFolderStory {
	folder?: Folder | undefined;
	folderId?: number;
	story?: Story | undefined;
	storyId?: number;

	constructor(data?: IFolderStory) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.folder = _data["folder"] ? Folder.fromJS(_data["folder"]) : <any>undefined;
			this.folderId = _data["folderId"];
			this.story = _data["story"] ? Story.fromJS(_data["story"]) : <any>undefined;
			this.storyId = _data["storyId"];
		}
	}

	static fromJS(data: any): FolderStory {
		data = typeof data === 'object' ? data : {};
		let result = new FolderStory();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["folder"] = this.folder ? this.folder.toJSON() : <any>undefined;
		data["folderId"] = this.folderId;
		data["story"] = this.story ? this.story.toJSON() : <any>undefined;
		data["storyId"] = this.storyId;
		return data;
	}
}

export interface IFolderStory {
	folder?: Folder | undefined;
	folderId?: number;
	story?: Story | undefined;
	storyId?: number;
}

export class Folder extends BaseModel implements IFolder {
	name?: string | undefined;
	slug?: string | undefined;
	description?: string | undefined;
	club?: Club | undefined;
	clubId?: number;
	parentFolder?: Folder | undefined;
	parentFolderId?: number | undefined;
	childFolders?: Folder[] | undefined;
	stories?: Story[] | undefined;
	storiesCount?: number;
	accessLevel?: EClubMemberRoles;

	constructor(data?: IFolder) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.name = _data["name"];
			this.slug = _data["slug"];
			this.description = _data["description"];
			this.club = _data["club"] ? Club.fromJS(_data["club"]) : <any>undefined;
			this.clubId = _data["clubId"];
			this.parentFolder = _data["parentFolder"] ? Folder.fromJS(_data["parentFolder"]) : <any>undefined;
			this.parentFolderId = _data["parentFolderId"];
			if (Array.isArray(_data["childFolders"])) {
				this.childFolders = [] as any;
				for (let item of _data["childFolders"])
					this.childFolders!.push(Folder.fromJS(item));
			}
			if (Array.isArray(_data["stories"])) {
				this.stories = [] as any;
				for (let item of _data["stories"])
					this.stories!.push(Story.fromJS(item));
			}
			this.storiesCount = _data["storiesCount"];
			this.accessLevel = _data["accessLevel"];
		}
	}

	static fromJS(data: any): Folder {
		data = typeof data === 'object' ? data : {};
		let result = new Folder();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		data["slug"] = this.slug;
		data["description"] = this.description;
		data["club"] = this.club ? this.club.toJSON() : <any>undefined;
		data["clubId"] = this.clubId;
		data["parentFolder"] = this.parentFolder ? this.parentFolder.toJSON() : <any>undefined;
		data["parentFolderId"] = this.parentFolderId;
		if (Array.isArray(this.childFolders)) {
			data["childFolders"] = [];
			for (let item of this.childFolders)
				data["childFolders"].push(item.toJSON());
		}
		if (Array.isArray(this.stories)) {
			data["stories"] = [];
			for (let item of this.stories)
				data["stories"].push(item.toJSON());
		}
		data["storiesCount"] = this.storiesCount;
		data["accessLevel"] = this.accessLevel;
		super.toJSON(data);
		return data;
	}
}

export interface IFolder extends IBaseModel {
	name?: string | undefined;
	slug?: string | undefined;
	description?: string | undefined;
	club?: Club | undefined;
	clubId?: number;
	parentFolder?: Folder | undefined;
	parentFolderId?: number | undefined;
	childFolders?: Folder[] | undefined;
	stories?: Story[] | undefined;
	storiesCount?: number;
	accessLevel?: EClubMemberRoles;
}

export class Club extends BaseModel implements IClub {
	name?: string | undefined;
	slug?: string | undefined;
	hook?: string | undefined;
	description?: string | undefined;
	icon?: string | undefined;
	iconId?: string | undefined;
	creationDate?: Date;
	clubMembers?: ClubMember[] | undefined;
	threads?: ClubThread[] | undefined;
	folders?: Folder[] | undefined;
	reports?: Report[] | undefined;

	constructor(data?: IClub) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.name = _data["name"];
			this.slug = _data["slug"];
			this.hook = _data["hook"];
			this.description = _data["description"];
			this.icon = _data["icon"];
			this.iconId = _data["iconId"];
			this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
			if (Array.isArray(_data["clubMembers"])) {
				this.clubMembers = [] as any;
				for (let item of _data["clubMembers"])
					this.clubMembers!.push(ClubMember.fromJS(item));
			}
			if (Array.isArray(_data["threads"])) {
				this.threads = [] as any;
				for (let item of _data["threads"])
					this.threads!.push(ClubThread.fromJS(item));
			}
			if (Array.isArray(_data["folders"])) {
				this.folders = [] as any;
				for (let item of _data["folders"])
					this.folders!.push(Folder.fromJS(item));
			}
			if (Array.isArray(_data["reports"])) {
				this.reports = [] as any;
				for (let item of _data["reports"])
					this.reports!.push(Report.fromJS(item));
			}
		}
	}

	static fromJS(data: any): Club {
		data = typeof data === 'object' ? data : {};
		let result = new Club();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		data["slug"] = this.slug;
		data["hook"] = this.hook;
		data["description"] = this.description;
		data["icon"] = this.icon;
		data["iconId"] = this.iconId;
		data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
		if (Array.isArray(this.clubMembers)) {
			data["clubMembers"] = [];
			for (let item of this.clubMembers)
				data["clubMembers"].push(item.toJSON());
		}
		if (Array.isArray(this.threads)) {
			data["threads"] = [];
			for (let item of this.threads)
				data["threads"].push(item.toJSON());
		}
		if (Array.isArray(this.folders)) {
			data["folders"] = [];
			for (let item of this.folders)
				data["folders"].push(item.toJSON());
		}
		if (Array.isArray(this.reports)) {
			data["reports"] = [];
			for (let item of this.reports)
				data["reports"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface IClub extends IBaseModel {
	name?: string | undefined;
	slug?: string | undefined;
	hook?: string | undefined;
	description?: string | undefined;
	icon?: string | undefined;
	iconId?: string | undefined;
	creationDate?: Date;
	clubMembers?: ClubMember[] | undefined;
	threads?: ClubThread[] | undefined;
	folders?: Folder[] | undefined;
	reports?: Report[] | undefined;
}

export class ClubMember implements IClubMember {
	member?: OgmaUser | undefined;
	memberId?: number;
	club?: Club | undefined;
	clubId?: number;
	role?: EClubMemberRoles;
	memberSince?: Date;

	constructor(data?: IClubMember) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.member = _data["member"] ? OgmaUser.fromJS(_data["member"]) : <any>undefined;
			this.memberId = _data["memberId"];
			this.club = _data["club"] ? Club.fromJS(_data["club"]) : <any>undefined;
			this.clubId = _data["clubId"];
			this.role = _data["role"];
			this.memberSince = _data["memberSince"] ? new Date(_data["memberSince"].toString()) : <any>undefined;
		}
	}

	static fromJS(data: any): ClubMember {
		data = typeof data === 'object' ? data : {};
		let result = new ClubMember();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["member"] = this.member ? this.member.toJSON() : <any>undefined;
		data["memberId"] = this.memberId;
		data["club"] = this.club ? this.club.toJSON() : <any>undefined;
		data["clubId"] = this.clubId;
		data["role"] = this.role;
		data["memberSince"] = this.memberSince ? this.memberSince.toISOString() : <any>undefined;
		return data;
	}
}

export interface IClubMember {
	member?: OgmaUser | undefined;
	memberId?: number;
	club?: Club | undefined;
	clubId?: number;
	role?: EClubMemberRoles;
	memberSince?: Date;
}

/** Represents a user in the identity system */
export class IdentityUserOfLong implements IIdentityUserOfLong {
	/** Gets or sets the primary key for this user. */
	id?: number;
	/** Gets or sets the user name for this user. */
	userName?: string | undefined;
	/** Gets or sets the normalized user name for this user. */
	normalizedUserName?: string | undefined;
	/** Gets or sets the email address for this user. */
	email?: string | undefined;
	/** Gets or sets the normalized email address for this user. */
	normalizedEmail?: string | undefined;
	/** Gets or sets a flag indicating if a user has confirmed their email address. */
	emailConfirmed?: boolean;
	/** Gets or sets a salted and hashed representation of the password for this user. */
	passwordHash?: string | undefined;
	/** A random value that must change whenever a users credentials change (password changed, login removed) */
	securityStamp?: string | undefined;
	/** A random value that must change whenever a user is persisted to the store */
	concurrencyStamp?: string | undefined;
	/** Gets or sets a telephone number for the user. */
	phoneNumber?: string | undefined;
	/** Gets or sets a flag indicating if a user has confirmed their telephone address. */
	phoneNumberConfirmed?: boolean;
	/** Gets or sets a flag indicating if two factor authentication is enabled for this user. */
	twoFactorEnabled?: boolean;
	/** Gets or sets the date and time, in UTC, when any user lockout ends. */
	lockoutEnd?: Date | undefined;
	/** Gets or sets a flag indicating if the user could be locked out. */
	lockoutEnabled?: boolean;
	/** Gets or sets the number of failed login attempts for the current user. */
	accessFailedCount?: number;

	constructor(data?: IIdentityUserOfLong) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.userName = _data["userName"];
			this.normalizedUserName = _data["normalizedUserName"];
			this.email = _data["email"];
			this.normalizedEmail = _data["normalizedEmail"];
			this.emailConfirmed = _data["emailConfirmed"];
			this.passwordHash = _data["passwordHash"];
			this.securityStamp = _data["securityStamp"];
			this.concurrencyStamp = _data["concurrencyStamp"];
			this.phoneNumber = _data["phoneNumber"];
			this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
			this.twoFactorEnabled = _data["twoFactorEnabled"];
			this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
			this.lockoutEnabled = _data["lockoutEnabled"];
			this.accessFailedCount = _data["accessFailedCount"];
		}
	}

	static fromJS(data: any): IdentityUserOfLong {
		data = typeof data === 'object' ? data : {};
		let result = new IdentityUserOfLong();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["userName"] = this.userName;
		data["normalizedUserName"] = this.normalizedUserName;
		data["email"] = this.email;
		data["normalizedEmail"] = this.normalizedEmail;
		data["emailConfirmed"] = this.emailConfirmed;
		data["passwordHash"] = this.passwordHash;
		data["securityStamp"] = this.securityStamp;
		data["concurrencyStamp"] = this.concurrencyStamp;
		data["phoneNumber"] = this.phoneNumber;
		data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
		data["twoFactorEnabled"] = this.twoFactorEnabled;
		data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
		data["lockoutEnabled"] = this.lockoutEnabled;
		data["accessFailedCount"] = this.accessFailedCount;
		return data;
	}
}

/** Represents a user in the identity system */
export interface IIdentityUserOfLong {
	/** Gets or sets the primary key for this user. */
	id?: number;
	/** Gets or sets the user name for this user. */
	userName?: string | undefined;
	/** Gets or sets the normalized user name for this user. */
	normalizedUserName?: string | undefined;
	/** Gets or sets the email address for this user. */
	email?: string | undefined;
	/** Gets or sets the normalized email address for this user. */
	normalizedEmail?: string | undefined;
	/** Gets or sets a flag indicating if a user has confirmed their email address. */
	emailConfirmed?: boolean;
	/** Gets or sets a salted and hashed representation of the password for this user. */
	passwordHash?: string | undefined;
	/** A random value that must change whenever a users credentials change (password changed, login removed) */
	securityStamp?: string | undefined;
	/** A random value that must change whenever a user is persisted to the store */
	concurrencyStamp?: string | undefined;
	/** Gets or sets a telephone number for the user. */
	phoneNumber?: string | undefined;
	/** Gets or sets a flag indicating if a user has confirmed their telephone address. */
	phoneNumberConfirmed?: boolean;
	/** Gets or sets a flag indicating if two factor authentication is enabled for this user. */
	twoFactorEnabled?: boolean;
	/** Gets or sets the date and time, in UTC, when any user lockout ends. */
	lockoutEnd?: Date | undefined;
	/** Gets or sets a flag indicating if the user could be locked out. */
	lockoutEnabled?: boolean;
	/** Gets or sets the number of failed login attempts for the current user. */
	accessFailedCount?: number;
}

export class OgmaUser extends IdentityUserOfLong implements IOgmaUser {
	title?: string | undefined;
	bio?: string | undefined;
	avatar?: string | undefined;
	avatarId?: string | undefined;
	registrationDate?: Date;
	lastActive?: Date;
	commentsThread?: CommentsThread | undefined;
	userRoles?: UserRole[] | undefined;
	stories?: Story[] | undefined;
	blogposts?: Blogpost[] | undefined;
	roles?: OgmaRole[] | undefined;
	blacklistedRatings?: BlacklistedRating[] | undefined;
	blacklistedTags?: BlacklistedTag[] | undefined;
	blockedUsers?: OgmaUser[] | undefined;
	blockedByUsers?: OgmaUser[] | undefined;
	followers?: OgmaUser[] | undefined;
	following?: OgmaUser[] | undefined;
	subscribedThreads?: CommentsThread[] | undefined;
	bannedUntil?: Date | undefined;
	mutedUntil?: Date | undefined;
	reports?: Report[] | undefined;
	notifications?: Notification[] | undefined;

	constructor(data?: IOgmaUser) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.title = _data["title"];
			this.bio = _data["bio"];
			this.avatar = _data["avatar"];
			this.avatarId = _data["avatarId"];
			this.registrationDate = _data["registrationDate"] ? new Date(_data["registrationDate"].toString()) : <any>undefined;
			this.lastActive = _data["lastActive"] ? new Date(_data["lastActive"].toString()) : <any>undefined;
			this.commentsThread = _data["commentsThread"] ? CommentsThread.fromJS(_data["commentsThread"]) : <any>undefined;
			if (Array.isArray(_data["userRoles"])) {
				this.userRoles = [] as any;
				for (let item of _data["userRoles"])
					this.userRoles!.push(UserRole.fromJS(item));
			}
			if (Array.isArray(_data["stories"])) {
				this.stories = [] as any;
				for (let item of _data["stories"])
					this.stories!.push(Story.fromJS(item));
			}
			if (Array.isArray(_data["blogposts"])) {
				this.blogposts = [] as any;
				for (let item of _data["blogposts"])
					this.blogposts!.push(Blogpost.fromJS(item));
			}
			if (Array.isArray(_data["roles"])) {
				this.roles = [] as any;
				for (let item of _data["roles"])
					this.roles!.push(OgmaRole.fromJS(item));
			}
			if (Array.isArray(_data["blacklistedRatings"])) {
				this.blacklistedRatings = [] as any;
				for (let item of _data["blacklistedRatings"])
					this.blacklistedRatings!.push(BlacklistedRating.fromJS(item));
			}
			if (Array.isArray(_data["blacklistedTags"])) {
				this.blacklistedTags = [] as any;
				for (let item of _data["blacklistedTags"])
					this.blacklistedTags!.push(BlacklistedTag.fromJS(item));
			}
			if (Array.isArray(_data["blockedUsers"])) {
				this.blockedUsers = [] as any;
				for (let item of _data["blockedUsers"])
					this.blockedUsers!.push(OgmaUser.fromJS(item));
			}
			if (Array.isArray(_data["blockedByUsers"])) {
				this.blockedByUsers = [] as any;
				for (let item of _data["blockedByUsers"])
					this.blockedByUsers!.push(OgmaUser.fromJS(item));
			}
			if (Array.isArray(_data["followers"])) {
				this.followers = [] as any;
				for (let item of _data["followers"])
					this.followers!.push(OgmaUser.fromJS(item));
			}
			if (Array.isArray(_data["following"])) {
				this.following = [] as any;
				for (let item of _data["following"])
					this.following!.push(OgmaUser.fromJS(item));
			}
			if (Array.isArray(_data["subscribedThreads"])) {
				this.subscribedThreads = [] as any;
				for (let item of _data["subscribedThreads"])
					this.subscribedThreads!.push(CommentsThread.fromJS(item));
			}
			this.bannedUntil = _data["bannedUntil"] ? new Date(_data["bannedUntil"].toString()) : <any>undefined;
			this.mutedUntil = _data["mutedUntil"] ? new Date(_data["mutedUntil"].toString()) : <any>undefined;
			if (Array.isArray(_data["reports"])) {
				this.reports = [] as any;
				for (let item of _data["reports"])
					this.reports!.push(Report.fromJS(item));
			}
			if (Array.isArray(_data["notifications"])) {
				this.notifications = [] as any;
				for (let item of _data["notifications"])
					this.notifications!.push(Notification.fromJS(item));
			}
		}
	}

	static fromJS(data: any): OgmaUser {
		data = typeof data === 'object' ? data : {};
		let result = new OgmaUser();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["title"] = this.title;
		data["bio"] = this.bio;
		data["avatar"] = this.avatar;
		data["avatarId"] = this.avatarId;
		data["registrationDate"] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
		data["lastActive"] = this.lastActive ? this.lastActive.toISOString() : <any>undefined;
		data["commentsThread"] = this.commentsThread ? this.commentsThread.toJSON() : <any>undefined;
		if (Array.isArray(this.userRoles)) {
			data["userRoles"] = [];
			for (let item of this.userRoles)
				data["userRoles"].push(item.toJSON());
		}
		if (Array.isArray(this.stories)) {
			data["stories"] = [];
			for (let item of this.stories)
				data["stories"].push(item.toJSON());
		}
		if (Array.isArray(this.blogposts)) {
			data["blogposts"] = [];
			for (let item of this.blogposts)
				data["blogposts"].push(item.toJSON());
		}
		if (Array.isArray(this.roles)) {
			data["roles"] = [];
			for (let item of this.roles)
				data["roles"].push(item.toJSON());
		}
		if (Array.isArray(this.blacklistedRatings)) {
			data["blacklistedRatings"] = [];
			for (let item of this.blacklistedRatings)
				data["blacklistedRatings"].push(item.toJSON());
		}
		if (Array.isArray(this.blacklistedTags)) {
			data["blacklistedTags"] = [];
			for (let item of this.blacklistedTags)
				data["blacklistedTags"].push(item.toJSON());
		}
		if (Array.isArray(this.blockedUsers)) {
			data["blockedUsers"] = [];
			for (let item of this.blockedUsers)
				data["blockedUsers"].push(item.toJSON());
		}
		if (Array.isArray(this.blockedByUsers)) {
			data["blockedByUsers"] = [];
			for (let item of this.blockedByUsers)
				data["blockedByUsers"].push(item.toJSON());
		}
		if (Array.isArray(this.followers)) {
			data["followers"] = [];
			for (let item of this.followers)
				data["followers"].push(item.toJSON());
		}
		if (Array.isArray(this.following)) {
			data["following"] = [];
			for (let item of this.following)
				data["following"].push(item.toJSON());
		}
		if (Array.isArray(this.subscribedThreads)) {
			data["subscribedThreads"] = [];
			for (let item of this.subscribedThreads)
				data["subscribedThreads"].push(item.toJSON());
		}
		data["bannedUntil"] = this.bannedUntil ? this.bannedUntil.toISOString() : <any>undefined;
		data["mutedUntil"] = this.mutedUntil ? this.mutedUntil.toISOString() : <any>undefined;
		if (Array.isArray(this.reports)) {
			data["reports"] = [];
			for (let item of this.reports)
				data["reports"].push(item.toJSON());
		}
		if (Array.isArray(this.notifications)) {
			data["notifications"] = [];
			for (let item of this.notifications)
				data["notifications"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface IOgmaUser extends IIdentityUserOfLong {
	title?: string | undefined;
	bio?: string | undefined;
	avatar?: string | undefined;
	avatarId?: string | undefined;
	registrationDate?: Date;
	lastActive?: Date;
	commentsThread?: CommentsThread | undefined;
	userRoles?: UserRole[] | undefined;
	stories?: Story[] | undefined;
	blogposts?: Blogpost[] | undefined;
	roles?: OgmaRole[] | undefined;
	blacklistedRatings?: BlacklistedRating[] | undefined;
	blacklistedTags?: BlacklistedTag[] | undefined;
	blockedUsers?: OgmaUser[] | undefined;
	blockedByUsers?: OgmaUser[] | undefined;
	followers?: OgmaUser[] | undefined;
	following?: OgmaUser[] | undefined;
	subscribedThreads?: CommentsThread[] | undefined;
	bannedUntil?: Date | undefined;
	mutedUntil?: Date | undefined;
	reports?: Report[] | undefined;
	notifications?: Notification[] | undefined;
}

export class CommentsThread extends BaseModel implements ICommentsThread {
	comments?: Comment[] | undefined;
	commentsCount?: number;
	lockDate?: Date | undefined;
	user?: OgmaUser | undefined;
	userId?: number | undefined;
	chapter?: Chapter | undefined;
	chapterId?: number | undefined;
	blogpost?: Blogpost | undefined;
	blogpostId?: number | undefined;
	clubThread?: ClubThread | undefined;
	clubThreadId?: number | undefined;
	subscribers?: OgmaUser[] | undefined;

	constructor(data?: ICommentsThread) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			if (Array.isArray(_data["comments"])) {
				this.comments = [] as any;
				for (let item of _data["comments"])
					this.comments!.push(Comment.fromJS(item));
			}
			this.commentsCount = _data["commentsCount"];
			this.lockDate = _data["lockDate"] ? new Date(_data["lockDate"].toString()) : <any>undefined;
			this.user = _data["user"] ? OgmaUser.fromJS(_data["user"]) : <any>undefined;
			this.userId = _data["userId"];
			this.chapter = _data["chapter"] ? Chapter.fromJS(_data["chapter"]) : <any>undefined;
			this.chapterId = _data["chapterId"];
			this.blogpost = _data["blogpost"] ? Blogpost.fromJS(_data["blogpost"]) : <any>undefined;
			this.blogpostId = _data["blogpostId"];
			this.clubThread = _data["clubThread"] ? ClubThread.fromJS(_data["clubThread"]) : <any>undefined;
			this.clubThreadId = _data["clubThreadId"];
			if (Array.isArray(_data["subscribers"])) {
				this.subscribers = [] as any;
				for (let item of _data["subscribers"])
					this.subscribers!.push(OgmaUser.fromJS(item));
			}
		}
	}

	static fromJS(data: any): CommentsThread {
		data = typeof data === 'object' ? data : {};
		let result = new CommentsThread();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		if (Array.isArray(this.comments)) {
			data["comments"] = [];
			for (let item of this.comments)
				data["comments"].push(item.toJSON());
		}
		data["commentsCount"] = this.commentsCount;
		data["lockDate"] = this.lockDate ? this.lockDate.toISOString() : <any>undefined;
		data["user"] = this.user ? this.user.toJSON() : <any>undefined;
		data["userId"] = this.userId;
		data["chapter"] = this.chapter ? this.chapter.toJSON() : <any>undefined;
		data["chapterId"] = this.chapterId;
		data["blogpost"] = this.blogpost ? this.blogpost.toJSON() : <any>undefined;
		data["blogpostId"] = this.blogpostId;
		data["clubThread"] = this.clubThread ? this.clubThread.toJSON() : <any>undefined;
		data["clubThreadId"] = this.clubThreadId;
		if (Array.isArray(this.subscribers)) {
			data["subscribers"] = [];
			for (let item of this.subscribers)
				data["subscribers"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface ICommentsThread extends IBaseModel {
	comments?: Comment[] | undefined;
	commentsCount?: number;
	lockDate?: Date | undefined;
	user?: OgmaUser | undefined;
	userId?: number | undefined;
	chapter?: Chapter | undefined;
	chapterId?: number | undefined;
	blogpost?: Blogpost | undefined;
	blogpostId?: number | undefined;
	clubThread?: ClubThread | undefined;
	clubThreadId?: number | undefined;
	subscribers?: OgmaUser[] | undefined;
}

export class Comment extends BaseModel implements IComment {
	commentsThread?: CommentsThread | undefined;
	commentsThreadId?: number;
	author?: OgmaUser | undefined;
	authorId?: number | undefined;
	dateTime?: Date;
	lastEdit?: Date | undefined;
	body?: string | undefined;
	deletedBy?: EDeletedBy | undefined;
	deletedByUser?: OgmaUser | undefined;
	deletedByUserId?: number | undefined;
	revisions?: CommentRevision[] | undefined;
	editCount?: number;
	reports?: Report[] | undefined;

	constructor(data?: IComment) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.commentsThread = _data["commentsThread"] ? CommentsThread.fromJS(_data["commentsThread"]) : <any>undefined;
			this.commentsThreadId = _data["commentsThreadId"];
			this.author = _data["author"] ? OgmaUser.fromJS(_data["author"]) : <any>undefined;
			this.authorId = _data["authorId"];
			this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
			this.lastEdit = _data["lastEdit"] ? new Date(_data["lastEdit"].toString()) : <any>undefined;
			this.body = _data["body"];
			this.deletedBy = _data["deletedBy"];
			this.deletedByUser = _data["deletedByUser"] ? OgmaUser.fromJS(_data["deletedByUser"]) : <any>undefined;
			this.deletedByUserId = _data["deletedByUserId"];
			if (Array.isArray(_data["revisions"])) {
				this.revisions = [] as any;
				for (let item of _data["revisions"])
					this.revisions!.push(CommentRevision.fromJS(item));
			}
			this.editCount = _data["editCount"];
			if (Array.isArray(_data["reports"])) {
				this.reports = [] as any;
				for (let item of _data["reports"])
					this.reports!.push(Report.fromJS(item));
			}
		}
	}

	static fromJS(data: any): Comment {
		data = typeof data === 'object' ? data : {};
		let result = new Comment();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["commentsThread"] = this.commentsThread ? this.commentsThread.toJSON() : <any>undefined;
		data["commentsThreadId"] = this.commentsThreadId;
		data["author"] = this.author ? this.author.toJSON() : <any>undefined;
		data["authorId"] = this.authorId;
		data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
		data["lastEdit"] = this.lastEdit ? this.lastEdit.toISOString() : <any>undefined;
		data["body"] = this.body;
		data["deletedBy"] = this.deletedBy;
		data["deletedByUser"] = this.deletedByUser ? this.deletedByUser.toJSON() : <any>undefined;
		data["deletedByUserId"] = this.deletedByUserId;
		if (Array.isArray(this.revisions)) {
			data["revisions"] = [];
			for (let item of this.revisions)
				data["revisions"].push(item.toJSON());
		}
		data["editCount"] = this.editCount;
		if (Array.isArray(this.reports)) {
			data["reports"] = [];
			for (let item of this.reports)
				data["reports"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface IComment extends IBaseModel {
	commentsThread?: CommentsThread | undefined;
	commentsThreadId?: number;
	author?: OgmaUser | undefined;
	authorId?: number | undefined;
	dateTime?: Date;
	lastEdit?: Date | undefined;
	body?: string | undefined;
	deletedBy?: EDeletedBy | undefined;
	deletedByUser?: OgmaUser | undefined;
	deletedByUserId?: number | undefined;
	revisions?: CommentRevision[] | undefined;
	editCount?: number;
	reports?: Report[] | undefined;
}

export class CommentRevision extends BaseModel implements ICommentRevision {
	editTime?: Date;
	body?: string | undefined;
	parent?: Comment | undefined;
	parentId?: number;

	constructor(data?: ICommentRevision) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.editTime = _data["editTime"] ? new Date(_data["editTime"].toString()) : <any>undefined;
			this.body = _data["body"];
			this.parent = _data["parent"] ? Comment.fromJS(_data["parent"]) : <any>undefined;
			this.parentId = _data["parentId"];
		}
	}

	static fromJS(data: any): CommentRevision {
		data = typeof data === 'object' ? data : {};
		let result = new CommentRevision();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["editTime"] = this.editTime ? this.editTime.toISOString() : <any>undefined;
		data["body"] = this.body;
		data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
		data["parentId"] = this.parentId;
		super.toJSON(data);
		return data;
	}
}

export interface ICommentRevision extends IBaseModel {
	editTime?: Date;
	body?: string | undefined;
	parent?: Comment | undefined;
	parentId?: number;
}

export class Report extends BaseModel implements IReport {
	reporter?: OgmaUser | undefined;
	reporterId?: number;
	reportDate?: Date;
	reason?: string | undefined;
	contentType?: string | undefined;
	comment?: Comment | undefined;
	commentId?: number | undefined;
	user?: OgmaUser | undefined;
	userId?: number | undefined;
	story?: Story | undefined;
	storyId?: number | undefined;
	chapter?: Chapter | undefined;
	chapterId?: number | undefined;
	blogpost?: Blogpost | undefined;
	blogpostId?: number | undefined;
	club?: Club | undefined;
	clubId?: number | undefined;

	constructor(data?: IReport) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.reporter = _data["reporter"] ? OgmaUser.fromJS(_data["reporter"]) : <any>undefined;
			this.reporterId = _data["reporterId"];
			this.reportDate = _data["reportDate"] ? new Date(_data["reportDate"].toString()) : <any>undefined;
			this.reason = _data["reason"];
			this.contentType = _data["contentType"];
			this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>undefined;
			this.commentId = _data["commentId"];
			this.user = _data["user"] ? OgmaUser.fromJS(_data["user"]) : <any>undefined;
			this.userId = _data["userId"];
			this.story = _data["story"] ? Story.fromJS(_data["story"]) : <any>undefined;
			this.storyId = _data["storyId"];
			this.chapter = _data["chapter"] ? Chapter.fromJS(_data["chapter"]) : <any>undefined;
			this.chapterId = _data["chapterId"];
			this.blogpost = _data["blogpost"] ? Blogpost.fromJS(_data["blogpost"]) : <any>undefined;
			this.blogpostId = _data["blogpostId"];
			this.club = _data["club"] ? Club.fromJS(_data["club"]) : <any>undefined;
			this.clubId = _data["clubId"];
		}
	}

	static fromJS(data: any): Report {
		data = typeof data === 'object' ? data : {};
		let result = new Report();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["reporter"] = this.reporter ? this.reporter.toJSON() : <any>undefined;
		data["reporterId"] = this.reporterId;
		data["reportDate"] = this.reportDate ? this.reportDate.toISOString() : <any>undefined;
		data["reason"] = this.reason;
		data["contentType"] = this.contentType;
		data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
		data["commentId"] = this.commentId;
		data["user"] = this.user ? this.user.toJSON() : <any>undefined;
		data["userId"] = this.userId;
		data["story"] = this.story ? this.story.toJSON() : <any>undefined;
		data["storyId"] = this.storyId;
		data["chapter"] = this.chapter ? this.chapter.toJSON() : <any>undefined;
		data["chapterId"] = this.chapterId;
		data["blogpost"] = this.blogpost ? this.blogpost.toJSON() : <any>undefined;
		data["blogpostId"] = this.blogpostId;
		data["club"] = this.club ? this.club.toJSON() : <any>undefined;
		data["clubId"] = this.clubId;
		super.toJSON(data);
		return data;
	}
}

export interface IReport extends IBaseModel {
	reporter?: OgmaUser | undefined;
	reporterId?: number;
	reportDate?: Date;
	reason?: string | undefined;
	contentType?: string | undefined;
	comment?: Comment | undefined;
	commentId?: number | undefined;
	user?: OgmaUser | undefined;
	userId?: number | undefined;
	story?: Story | undefined;
	storyId?: number | undefined;
	chapter?: Chapter | undefined;
	chapterId?: number | undefined;
	blogpost?: Blogpost | undefined;
	blogpostId?: number | undefined;
	club?: Club | undefined;
	clubId?: number | undefined;
}

export class Story extends BaseModel implements IStory {
	author?: OgmaUser | undefined;
	authorId?: number;
	title?: string | undefined;
	slug?: string | undefined;
	description?: string | undefined;
	hook?: string | undefined;
	cover?: string | undefined;
	coverId?: string | undefined;
	creationDate?: Date;
	publicationDate?: Date | undefined;
	chapters?: Chapter[] | undefined;
	tags?: Tag[] | undefined;
	votes?: Vote[] | undefined;
	rating?: Rating | undefined;
	ratingId?: number;
	status?: EStoryStatus;
	wordCount?: number;
	chapterCount?: number;
	folders?: Folder[] | undefined;
	contentBlock?: ContentBlock | undefined;
	contentBlockId?: number | undefined;
	reports?: Report[] | undefined;
	shelves?: Shelf[] | undefined;

	constructor(data?: IStory) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.author = _data["author"] ? OgmaUser.fromJS(_data["author"]) : <any>undefined;
			this.authorId = _data["authorId"];
			this.title = _data["title"];
			this.slug = _data["slug"];
			this.description = _data["description"];
			this.hook = _data["hook"];
			this.cover = _data["cover"];
			this.coverId = _data["coverId"];
			this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
			this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
			if (Array.isArray(_data["chapters"])) {
				this.chapters = [] as any;
				for (let item of _data["chapters"])
					this.chapters!.push(Chapter.fromJS(item));
			}
			if (Array.isArray(_data["tags"])) {
				this.tags = [] as any;
				for (let item of _data["tags"])
					this.tags!.push(Tag.fromJS(item));
			}
			if (Array.isArray(_data["votes"])) {
				this.votes = [] as any;
				for (let item of _data["votes"])
					this.votes!.push(Vote.fromJS(item));
			}
			this.rating = _data["rating"] ? Rating.fromJS(_data["rating"]) : <any>undefined;
			this.ratingId = _data["ratingId"];
			this.status = _data["status"];
			this.wordCount = _data["wordCount"];
			this.chapterCount = _data["chapterCount"];
			if (Array.isArray(_data["folders"])) {
				this.folders = [] as any;
				for (let item of _data["folders"])
					this.folders!.push(Folder.fromJS(item));
			}
			this.contentBlock = _data["contentBlock"] ? ContentBlock.fromJS(_data["contentBlock"]) : <any>undefined;
			this.contentBlockId = _data["contentBlockId"];
			if (Array.isArray(_data["reports"])) {
				this.reports = [] as any;
				for (let item of _data["reports"])
					this.reports!.push(Report.fromJS(item));
			}
			if (Array.isArray(_data["shelves"])) {
				this.shelves = [] as any;
				for (let item of _data["shelves"])
					this.shelves!.push(Shelf.fromJS(item));
			}
		}
	}

	static fromJS(data: any): Story {
		data = typeof data === 'object' ? data : {};
		let result = new Story();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["author"] = this.author ? this.author.toJSON() : <any>undefined;
		data["authorId"] = this.authorId;
		data["title"] = this.title;
		data["slug"] = this.slug;
		data["description"] = this.description;
		data["hook"] = this.hook;
		data["cover"] = this.cover;
		data["coverId"] = this.coverId;
		data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
		data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
		if (Array.isArray(this.chapters)) {
			data["chapters"] = [];
			for (let item of this.chapters)
				data["chapters"].push(item.toJSON());
		}
		if (Array.isArray(this.tags)) {
			data["tags"] = [];
			for (let item of this.tags)
				data["tags"].push(item.toJSON());
		}
		if (Array.isArray(this.votes)) {
			data["votes"] = [];
			for (let item of this.votes)
				data["votes"].push(item.toJSON());
		}
		data["rating"] = this.rating ? this.rating.toJSON() : <any>undefined;
		data["ratingId"] = this.ratingId;
		data["status"] = this.status;
		data["wordCount"] = this.wordCount;
		data["chapterCount"] = this.chapterCount;
		if (Array.isArray(this.folders)) {
			data["folders"] = [];
			for (let item of this.folders)
				data["folders"].push(item.toJSON());
		}
		data["contentBlock"] = this.contentBlock ? this.contentBlock.toJSON() : <any>undefined;
		data["contentBlockId"] = this.contentBlockId;
		if (Array.isArray(this.reports)) {
			data["reports"] = [];
			for (let item of this.reports)
				data["reports"].push(item.toJSON());
		}
		if (Array.isArray(this.shelves)) {
			data["shelves"] = [];
			for (let item of this.shelves)
				data["shelves"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface IStory extends IBaseModel {
	author?: OgmaUser | undefined;
	authorId?: number;
	title?: string | undefined;
	slug?: string | undefined;
	description?: string | undefined;
	hook?: string | undefined;
	cover?: string | undefined;
	coverId?: string | undefined;
	creationDate?: Date;
	publicationDate?: Date | undefined;
	chapters?: Chapter[] | undefined;
	tags?: Tag[] | undefined;
	votes?: Vote[] | undefined;
	rating?: Rating | undefined;
	ratingId?: number;
	status?: EStoryStatus;
	wordCount?: number;
	chapterCount?: number;
	folders?: Folder[] | undefined;
	contentBlock?: ContentBlock | undefined;
	contentBlockId?: number | undefined;
	reports?: Report[] | undefined;
	shelves?: Shelf[] | undefined;
}

export class Chapter extends BaseModel implements IChapter {
	order?: number;
	creationDate?: Date;
	publicationDate?: Date | undefined;
	title?: string | undefined;
	slug?: string | undefined;
	body?: string | undefined;
	startNotes?: string | undefined;
	endNotes?: string | undefined;
	wordCount?: number;
	commentsThread?: CommentsThread | undefined;
	story?: Story | undefined;
	storyId?: number;
	contentBlock?: ContentBlock | undefined;
	contentBlockId?: number | undefined;
	reports?: Report[] | undefined;

	constructor(data?: IChapter) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.order = _data["order"];
			this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
			this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
			this.title = _data["title"];
			this.slug = _data["slug"];
			this.body = _data["body"];
			this.startNotes = _data["startNotes"];
			this.endNotes = _data["endNotes"];
			this.wordCount = _data["wordCount"];
			this.commentsThread = _data["commentsThread"] ? CommentsThread.fromJS(_data["commentsThread"]) : <any>undefined;
			this.story = _data["story"] ? Story.fromJS(_data["story"]) : <any>undefined;
			this.storyId = _data["storyId"];
			this.contentBlock = _data["contentBlock"] ? ContentBlock.fromJS(_data["contentBlock"]) : <any>undefined;
			this.contentBlockId = _data["contentBlockId"];
			if (Array.isArray(_data["reports"])) {
				this.reports = [] as any;
				for (let item of _data["reports"])
					this.reports!.push(Report.fromJS(item));
			}
		}
	}

	static fromJS(data: any): Chapter {
		data = typeof data === 'object' ? data : {};
		let result = new Chapter();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["order"] = this.order;
		data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
		data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
		data["title"] = this.title;
		data["slug"] = this.slug;
		data["body"] = this.body;
		data["startNotes"] = this.startNotes;
		data["endNotes"] = this.endNotes;
		data["wordCount"] = this.wordCount;
		data["commentsThread"] = this.commentsThread ? this.commentsThread.toJSON() : <any>undefined;
		data["story"] = this.story ? this.story.toJSON() : <any>undefined;
		data["storyId"] = this.storyId;
		data["contentBlock"] = this.contentBlock ? this.contentBlock.toJSON() : <any>undefined;
		data["contentBlockId"] = this.contentBlockId;
		if (Array.isArray(this.reports)) {
			data["reports"] = [];
			for (let item of this.reports)
				data["reports"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface IChapter extends IBaseModel {
	order?: number;
	creationDate?: Date;
	publicationDate?: Date | undefined;
	title?: string | undefined;
	slug?: string | undefined;
	body?: string | undefined;
	startNotes?: string | undefined;
	endNotes?: string | undefined;
	wordCount?: number;
	commentsThread?: CommentsThread | undefined;
	story?: Story | undefined;
	storyId?: number;
	contentBlock?: ContentBlock | undefined;
	contentBlockId?: number | undefined;
	reports?: Report[] | undefined;
}

export class ContentBlock extends BaseModel implements IContentBlock {
	issuer?: OgmaUser | undefined;
	issuerId?: number;
	reason?: string | undefined;
	dateTime?: Date;
	type?: string | undefined;

	constructor(data?: IContentBlock) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.issuer = _data["issuer"] ? OgmaUser.fromJS(_data["issuer"]) : <any>undefined;
			this.issuerId = _data["issuerId"];
			this.reason = _data["reason"];
			this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
			this.type = _data["type"];
		}
	}

	static fromJS(data: any): ContentBlock {
		data = typeof data === 'object' ? data : {};
		let result = new ContentBlock();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["issuer"] = this.issuer ? this.issuer.toJSON() : <any>undefined;
		data["issuerId"] = this.issuerId;
		data["reason"] = this.reason;
		data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
		data["type"] = this.type;
		super.toJSON(data);
		return data;
	}
}

export interface IContentBlock extends IBaseModel {
	issuer?: OgmaUser | undefined;
	issuerId?: number;
	reason?: string | undefined;
	dateTime?: Date;
	type?: string | undefined;
}

export class Tag extends BaseModel implements ITag {
	name?: string | undefined;
	slug?: string | undefined;
	description?: string | undefined;
	namespace?: ETagNamespace | undefined;
	stories?: Story[] | undefined;

	constructor(data?: ITag) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.name = _data["name"];
			this.slug = _data["slug"];
			this.description = _data["description"];
			this.namespace = _data["namespace"];
			if (Array.isArray(_data["stories"])) {
				this.stories = [] as any;
				for (let item of _data["stories"])
					this.stories!.push(Story.fromJS(item));
			}
		}
	}

	static fromJS(data: any): Tag {
		data = typeof data === 'object' ? data : {};
		let result = new Tag();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		data["slug"] = this.slug;
		data["description"] = this.description;
		data["namespace"] = this.namespace;
		if (Array.isArray(this.stories)) {
			data["stories"] = [];
			for (let item of this.stories)
				data["stories"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface ITag extends IBaseModel {
	name?: string | undefined;
	slug?: string | undefined;
	description?: string | undefined;
	namespace?: ETagNamespace | undefined;
	stories?: Story[] | undefined;
}

export class Vote extends BaseModel implements IVote {
	user?: OgmaUser | undefined;
	userId?: number;
	storyId?: number;

	constructor(data?: IVote) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.user = _data["user"] ? OgmaUser.fromJS(_data["user"]) : <any>undefined;
			this.userId = _data["userId"];
			this.storyId = _data["storyId"];
		}
	}

	static fromJS(data: any): Vote {
		data = typeof data === 'object' ? data : {};
		let result = new Vote();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["user"] = this.user ? this.user.toJSON() : <any>undefined;
		data["userId"] = this.userId;
		data["storyId"] = this.storyId;
		super.toJSON(data);
		return data;
	}
}

export interface IVote extends IBaseModel {
	user?: OgmaUser | undefined;
	userId?: number;
	storyId?: number;
}

export class Rating extends BaseModel implements IRating {
	name?: string | undefined;
	description?: string | undefined;
	order?: number;
	icon?: string | undefined;
	iconId?: string | undefined;
	blacklistedByDefault?: boolean;

	constructor(data?: IRating) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.name = _data["name"];
			this.description = _data["description"];
			this.order = _data["order"];
			this.icon = _data["icon"];
			this.iconId = _data["iconId"];
			this.blacklistedByDefault = _data["blacklistedByDefault"];
		}
	}

	static fromJS(data: any): Rating {
		data = typeof data === 'object' ? data : {};
		let result = new Rating();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		data["description"] = this.description;
		data["order"] = this.order;
		data["icon"] = this.icon;
		data["iconId"] = this.iconId;
		data["blacklistedByDefault"] = this.blacklistedByDefault;
		super.toJSON(data);
		return data;
	}
}

export interface IRating extends IBaseModel {
	name?: string | undefined;
	description?: string | undefined;
	order?: number;
	icon?: string | undefined;
	iconId?: string | undefined;
	blacklistedByDefault?: boolean;
}

export enum EStoryStatus {
	InProgress = "InProgress",
	Completed = "Completed",
	OnHiatus = "OnHiatus",
	Cancelled = "Cancelled",
}

export class Shelf extends BaseModel implements IShelf {
	name?: string | undefined;
	description?: string | undefined;
	owner?: OgmaUser | undefined;
	ownerId?: number;
	isDefault?: boolean;
	isPublic?: boolean;
	isQuickAdd?: boolean;
	trackUpdates?: boolean;
	color?: string | undefined;
	icon?: Icon | undefined;
	iconId?: number | undefined;
	stories?: Story[] | undefined;

	constructor(data?: IShelf) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.name = _data["name"];
			this.description = _data["description"];
			this.owner = _data["owner"] ? OgmaUser.fromJS(_data["owner"]) : <any>undefined;
			this.ownerId = _data["ownerId"];
			this.isDefault = _data["isDefault"];
			this.isPublic = _data["isPublic"];
			this.isQuickAdd = _data["isQuickAdd"];
			this.trackUpdates = _data["trackUpdates"];
			this.color = _data["color"];
			this.icon = _data["icon"] ? Icon.fromJS(_data["icon"]) : <any>undefined;
			this.iconId = _data["iconId"];
			if (Array.isArray(_data["stories"])) {
				this.stories = [] as any;
				for (let item of _data["stories"])
					this.stories!.push(Story.fromJS(item));
			}
		}
	}

	static fromJS(data: any): Shelf {
		data = typeof data === 'object' ? data : {};
		let result = new Shelf();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		data["description"] = this.description;
		data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
		data["ownerId"] = this.ownerId;
		data["isDefault"] = this.isDefault;
		data["isPublic"] = this.isPublic;
		data["isQuickAdd"] = this.isQuickAdd;
		data["trackUpdates"] = this.trackUpdates;
		data["color"] = this.color;
		data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
		data["iconId"] = this.iconId;
		if (Array.isArray(this.stories)) {
			data["stories"] = [];
			for (let item of this.stories)
				data["stories"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface IShelf extends IBaseModel {
	name?: string | undefined;
	description?: string | undefined;
	owner?: OgmaUser | undefined;
	ownerId?: number;
	isDefault?: boolean;
	isPublic?: boolean;
	isQuickAdd?: boolean;
	trackUpdates?: boolean;
	color?: string | undefined;
	icon?: Icon | undefined;
	iconId?: number | undefined;
	stories?: Story[] | undefined;
}

export class Icon extends BaseModel implements IIcon {
	name?: string | undefined;

	constructor(data?: IIcon) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.name = _data["name"];
		}
	}

	static fromJS(data: any): Icon {
		data = typeof data === 'object' ? data : {};
		let result = new Icon();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["name"] = this.name;
		super.toJSON(data);
		return data;
	}
}

export interface IIcon extends IBaseModel {
	name?: string | undefined;
}

export class Blogpost extends BaseModel implements IBlogpost {
	title?: string | undefined;
	slug?: string | undefined;
	publicationDate?: Date | undefined;
	creationDate?: Date;
	author?: OgmaUser | undefined;
	authorId?: number;
	body?: string | undefined;
	commentsThread?: CommentsThread | undefined;
	wordCount?: number;
	hashtags?: string[] | undefined;
	attachedStory?: Story | undefined;
	attachedStoryId?: number | undefined;
	attachedChapter?: Chapter | undefined;
	attachedChapterId?: number | undefined;
	contentBlock?: ContentBlock | undefined;
	contentBlockId?: number | undefined;
	reports?: Report[] | undefined;

	constructor(data?: IBlogpost) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.title = _data["title"];
			this.slug = _data["slug"];
			this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
			this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
			this.author = _data["author"] ? OgmaUser.fromJS(_data["author"]) : <any>undefined;
			this.authorId = _data["authorId"];
			this.body = _data["body"];
			this.commentsThread = _data["commentsThread"] ? CommentsThread.fromJS(_data["commentsThread"]) : <any>undefined;
			this.wordCount = _data["wordCount"];
			if (Array.isArray(_data["hashtags"])) {
				this.hashtags = [] as any;
				for (let item of _data["hashtags"])
					this.hashtags!.push(item);
			}
			this.attachedStory = _data["attachedStory"] ? Story.fromJS(_data["attachedStory"]) : <any>undefined;
			this.attachedStoryId = _data["attachedStoryId"];
			this.attachedChapter = _data["attachedChapter"] ? Chapter.fromJS(_data["attachedChapter"]) : <any>undefined;
			this.attachedChapterId = _data["attachedChapterId"];
			this.contentBlock = _data["contentBlock"] ? ContentBlock.fromJS(_data["contentBlock"]) : <any>undefined;
			this.contentBlockId = _data["contentBlockId"];
			if (Array.isArray(_data["reports"])) {
				this.reports = [] as any;
				for (let item of _data["reports"])
					this.reports!.push(Report.fromJS(item));
			}
		}
	}

	static fromJS(data: any): Blogpost {
		data = typeof data === 'object' ? data : {};
		let result = new Blogpost();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["title"] = this.title;
		data["slug"] = this.slug;
		data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
		data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
		data["author"] = this.author ? this.author.toJSON() : <any>undefined;
		data["authorId"] = this.authorId;
		data["body"] = this.body;
		data["commentsThread"] = this.commentsThread ? this.commentsThread.toJSON() : <any>undefined;
		data["wordCount"] = this.wordCount;
		if (Array.isArray(this.hashtags)) {
			data["hashtags"] = [];
			for (let item of this.hashtags)
				data["hashtags"].push(item);
		}
		data["attachedStory"] = this.attachedStory ? this.attachedStory.toJSON() : <any>undefined;
		data["attachedStoryId"] = this.attachedStoryId;
		data["attachedChapter"] = this.attachedChapter ? this.attachedChapter.toJSON() : <any>undefined;
		data["attachedChapterId"] = this.attachedChapterId;
		data["contentBlock"] = this.contentBlock ? this.contentBlock.toJSON() : <any>undefined;
		data["contentBlockId"] = this.contentBlockId;
		if (Array.isArray(this.reports)) {
			data["reports"] = [];
			for (let item of this.reports)
				data["reports"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface IBlogpost extends IBaseModel {
	title?: string | undefined;
	slug?: string | undefined;
	publicationDate?: Date | undefined;
	creationDate?: Date;
	author?: OgmaUser | undefined;
	authorId?: number;
	body?: string | undefined;
	commentsThread?: CommentsThread | undefined;
	wordCount?: number;
	hashtags?: string[] | undefined;
	attachedStory?: Story | undefined;
	attachedStoryId?: number | undefined;
	attachedChapter?: Chapter | undefined;
	attachedChapterId?: number | undefined;
	contentBlock?: ContentBlock | undefined;
	contentBlockId?: number | undefined;
	reports?: Report[] | undefined;
}

export class ClubThread extends BaseModel implements IClubThread {
	title?: string | undefined;
	body?: string | undefined;
	author?: OgmaUser | undefined;
	authorId?: number | undefined;
	creationDate?: Date;
	commentsThread?: CommentsThread | undefined;
	club?: Club | undefined;
	clubId?: number;
	deletedAt?: Date | undefined;
	isPinned?: boolean;

	constructor(data?: IClubThread) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.title = _data["title"];
			this.body = _data["body"];
			this.author = _data["author"] ? OgmaUser.fromJS(_data["author"]) : <any>undefined;
			this.authorId = _data["authorId"];
			this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
			this.commentsThread = _data["commentsThread"] ? CommentsThread.fromJS(_data["commentsThread"]) : <any>undefined;
			this.club = _data["club"] ? Club.fromJS(_data["club"]) : <any>undefined;
			this.clubId = _data["clubId"];
			this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
			this.isPinned = _data["isPinned"];
		}
	}

	static fromJS(data: any): ClubThread {
		data = typeof data === 'object' ? data : {};
		let result = new ClubThread();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["title"] = this.title;
		data["body"] = this.body;
		data["author"] = this.author ? this.author.toJSON() : <any>undefined;
		data["authorId"] = this.authorId;
		data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
		data["commentsThread"] = this.commentsThread ? this.commentsThread.toJSON() : <any>undefined;
		data["club"] = this.club ? this.club.toJSON() : <any>undefined;
		data["clubId"] = this.clubId;
		data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
		data["isPinned"] = this.isPinned;
		super.toJSON(data);
		return data;
	}
}

export interface IClubThread extends IBaseModel {
	title?: string | undefined;
	body?: string | undefined;
	author?: OgmaUser | undefined;
	authorId?: number | undefined;
	creationDate?: Date;
	commentsThread?: CommentsThread | undefined;
	club?: Club | undefined;
	clubId?: number;
	deletedAt?: Date | undefined;
	isPinned?: boolean;
}

/** Represents the link between a user and a role. */
export class IdentityUserRoleOfLong implements IIdentityUserRoleOfLong {
	/** Gets or sets the primary key of the user that is linked to a role. */
	userId?: number;
	/** Gets or sets the primary key of the role that is linked to the user. */
	roleId?: number;

	constructor(data?: IIdentityUserRoleOfLong) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.userId = _data["userId"];
			this.roleId = _data["roleId"];
		}
	}

	static fromJS(data: any): IdentityUserRoleOfLong {
		data = typeof data === 'object' ? data : {};
		let result = new IdentityUserRoleOfLong();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["userId"] = this.userId;
		data["roleId"] = this.roleId;
		return data;
	}
}

/** Represents the link between a user and a role. */
export interface IIdentityUserRoleOfLong {
	/** Gets or sets the primary key of the user that is linked to a role. */
	userId?: number;
	/** Gets or sets the primary key of the role that is linked to the user. */
	roleId?: number;
}

export class UserRole extends IdentityUserRoleOfLong implements IUserRole {
	user!: OgmaUser;
	role!: OgmaRole;

	constructor(data?: IUserRole) {
		super(data);
		if (!data) {
			this.user = new OgmaUser();
			this.role = new OgmaRole();
		}
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.user = _data["user"] ? OgmaUser.fromJS(_data["user"]) : new OgmaUser();
			this.role = _data["role"] ? OgmaRole.fromJS(_data["role"]) : new OgmaRole();
		}
	}

	static fromJS(data: any): UserRole {
		data = typeof data === 'object' ? data : {};
		let result = new UserRole();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["user"] = this.user ? this.user.toJSON() : <any>undefined;
		data["role"] = this.role ? this.role.toJSON() : <any>undefined;
		super.toJSON(data);
		return data;
	}
}

export interface IUserRole extends IIdentityUserRoleOfLong {
	user: OgmaUser;
	role: OgmaRole;
}

/** Represents a role in the identity system */
export class IdentityRoleOfLong implements IIdentityRoleOfLong {
	/** Gets or sets the primary key for this role. */
	id?: number;
	/** Gets or sets the name for this role. */
	name?: string | undefined;
	/** Gets or sets the normalized name for this role. */
	normalizedName?: string | undefined;
	/** A random value that should change whenever a role is persisted to the store */
	concurrencyStamp?: string | undefined;

	constructor(data?: IIdentityRoleOfLong) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.normalizedName = _data["normalizedName"];
			this.concurrencyStamp = _data["concurrencyStamp"];
		}
	}

	static fromJS(data: any): IdentityRoleOfLong {
		data = typeof data === 'object' ? data : {};
		let result = new IdentityRoleOfLong();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["normalizedName"] = this.normalizedName;
		data["concurrencyStamp"] = this.concurrencyStamp;
		return data;
	}
}

/** Represents a role in the identity system */
export interface IIdentityRoleOfLong {
	/** Gets or sets the primary key for this role. */
	id?: number;
	/** Gets or sets the name for this role. */
	name?: string | undefined;
	/** Gets or sets the normalized name for this role. */
	normalizedName?: string | undefined;
	/** A random value that should change whenever a role is persisted to the store */
	concurrencyStamp?: string | undefined;
}

export class OgmaRole extends IdentityRoleOfLong implements IOgmaRole {
	isStaff?: boolean;
	color?: string | undefined;
	order?: number | undefined;
	users?: OgmaUser[] | undefined;

	constructor(data?: IOgmaRole) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.isStaff = _data["isStaff"];
			this.color = _data["color"];
			this.order = _data["order"];
			if (Array.isArray(_data["users"])) {
				this.users = [] as any;
				for (let item of _data["users"])
					this.users!.push(OgmaUser.fromJS(item));
			}
		}
	}

	static fromJS(data: any): OgmaRole {
		data = typeof data === 'object' ? data : {};
		let result = new OgmaRole();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["isStaff"] = this.isStaff;
		data["color"] = this.color;
		data["order"] = this.order;
		if (Array.isArray(this.users)) {
			data["users"] = [];
			for (let item of this.users)
				data["users"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface IOgmaRole extends IIdentityRoleOfLong {
	isStaff?: boolean;
	color?: string | undefined;
	order?: number | undefined;
	users?: OgmaUser[] | undefined;
}

export class BlacklistedRating implements IBlacklistedRating {
	user?: OgmaUser | undefined;
	userId?: number;
	rating?: Rating | undefined;
	ratingId?: number;

	constructor(data?: IBlacklistedRating) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.user = _data["user"] ? OgmaUser.fromJS(_data["user"]) : <any>undefined;
			this.userId = _data["userId"];
			this.rating = _data["rating"] ? Rating.fromJS(_data["rating"]) : <any>undefined;
			this.ratingId = _data["ratingId"];
		}
	}

	static fromJS(data: any): BlacklistedRating {
		data = typeof data === 'object' ? data : {};
		let result = new BlacklistedRating();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["user"] = this.user ? this.user.toJSON() : <any>undefined;
		data["userId"] = this.userId;
		data["rating"] = this.rating ? this.rating.toJSON() : <any>undefined;
		data["ratingId"] = this.ratingId;
		return data;
	}
}

export interface IBlacklistedRating {
	user?: OgmaUser | undefined;
	userId?: number;
	rating?: Rating | undefined;
	ratingId?: number;
}

export class BlacklistedTag implements IBlacklistedTag {
	user?: OgmaUser | undefined;
	userId?: number;
	tag?: Tag | undefined;
	tagId?: number;

	constructor(data?: IBlacklistedTag) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.user = _data["user"] ? OgmaUser.fromJS(_data["user"]) : <any>undefined;
			this.userId = _data["userId"];
			this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
			this.tagId = _data["tagId"];
		}
	}

	static fromJS(data: any): BlacklistedTag {
		data = typeof data === 'object' ? data : {};
		let result = new BlacklistedTag();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["user"] = this.user ? this.user.toJSON() : <any>undefined;
		data["userId"] = this.userId;
		data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
		data["tagId"] = this.tagId;
		return data;
	}
}

export interface IBlacklistedTag {
	user?: OgmaUser | undefined;
	userId?: number;
	tag?: Tag | undefined;
	tagId?: number;
}

export class Notification extends BaseModel implements INotification {
	body?: string | undefined;
	url?: string | undefined;
	dateTime?: Date;
	event?: ENotificationEvent;
	recipients?: OgmaUser[] | undefined;

	constructor(data?: INotification) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.body = _data["body"];
			this.url = _data["url"];
			this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
			this.event = _data["event"];
			if (Array.isArray(_data["recipients"])) {
				this.recipients = [] as any;
				for (let item of _data["recipients"])
					this.recipients!.push(OgmaUser.fromJS(item));
			}
		}
	}

	static fromJS(data: any): Notification {
		data = typeof data === 'object' ? data : {};
		let result = new Notification();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["body"] = this.body;
		data["url"] = this.url;
		data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
		data["event"] = this.event;
		if (Array.isArray(this.recipients)) {
			data["recipients"] = [];
			for (let item of this.recipients)
				data["recipients"].push(item.toJSON());
		}
		super.toJSON(data);
		return data;
	}
}

export interface INotification extends IBaseModel {
	body?: string | undefined;
	url?: string | undefined;
	dateTime?: Date;
	event?: ENotificationEvent;
	recipients?: OgmaUser[] | undefined;
}

export enum EClubMemberRoles {
	Founder = "Founder",
	Admin = "Admin",
	Moderator = "Moderator",
	User = "User",
}

export class AddStoryToFolderCommand implements IAddStoryToFolderCommand {
	folderId?: number;
	storyId?: number;

	constructor(data?: IAddStoryToFolderCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.folderId = _data["folderId"];
			this.storyId = _data["storyId"];
		}
	}

	static fromJS(data: any): AddStoryToFolderCommand {
		data = typeof data === 'object' ? data : {};
		let result = new AddStoryToFolderCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["folderId"] = this.folderId;
		data["storyId"] = this.storyId;
		return data;
	}
}

export interface IAddStoryToFolderCommand {
	folderId?: number;
	storyId?: number;
}

export class Faq extends BaseModel implements IFaq {
	question?: string | undefined;
	answer?: string | undefined;
	answerRendered?: string | undefined;

	constructor(data?: IFaq) {
		super(data);
	}

	init(_data?: any) {
		super.init(_data);
		if (_data) {
			this.question = _data["question"];
			this.answer = _data["answer"];
			this.answerRendered = _data["answerRendered"];
		}
	}

	static fromJS(data: any): Faq {
		data = typeof data === 'object' ? data : {};
		let result = new Faq();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["question"] = this.question;
		data["answer"] = this.answer;
		data["answerRendered"] = this.answerRendered;
		super.toJSON(data);
		return data;
	}
}

export interface IFaq extends IBaseModel {
	question?: string | undefined;
	answer?: string | undefined;
	answerRendered?: string | undefined;
}

export class UpdateFaqCommand implements IUpdateFaqCommand {
	id?: number;
	question?: string | undefined;
	answer?: string | undefined;

	constructor(data?: IUpdateFaqCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.question = _data["question"];
			this.answer = _data["answer"];
		}
	}

	static fromJS(data: any): UpdateFaqCommand {
		data = typeof data === 'object' ? data : {};
		let result = new UpdateFaqCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["question"] = this.question;
		data["answer"] = this.answer;
		return data;
	}
}

export interface IUpdateFaqCommand {
	id?: number;
	question?: string | undefined;
	answer?: string | undefined;
}

export class CreateFaqCommand implements ICreateFaqCommand {
	question?: string | undefined;
	answer?: string | undefined;

	constructor(data?: ICreateFaqCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.question = _data["question"];
			this.answer = _data["answer"];
		}
	}

	static fromJS(data: any): CreateFaqCommand {
		data = typeof data === 'object' ? data : {};
		let result = new CreateFaqCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["question"] = this.question;
		data["answer"] = this.answer;
		return data;
	}
}

export interface ICreateFaqCommand {
	question?: string | undefined;
	answer?: string | undefined;
}

export class CommandOfStory implements ICommandOfStory {
	objectId?: number;
	reason?: string | undefined;

	constructor(data?: ICommandOfStory) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.objectId = _data["objectId"];
			this.reason = _data["reason"];
		}
	}

	static fromJS(data: any): CommandOfStory {
		data = typeof data === 'object' ? data : {};
		let result = new CommandOfStory();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["objectId"] = this.objectId;
		data["reason"] = this.reason;
		return data;
	}
}

export interface ICommandOfStory {
	objectId?: number;
	reason?: string | undefined;
}

export class CommandOfChapter implements ICommandOfChapter {
	objectId?: number;
	reason?: string | undefined;

	constructor(data?: ICommandOfChapter) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.objectId = _data["objectId"];
			this.reason = _data["reason"];
		}
	}

	static fromJS(data: any): CommandOfChapter {
		data = typeof data === 'object' ? data : {};
		let result = new CommandOfChapter();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["objectId"] = this.objectId;
		data["reason"] = this.reason;
		return data;
	}
}

export interface ICommandOfChapter {
	objectId?: number;
	reason?: string | undefined;
}

export class CommandOfBlogpost implements ICommandOfBlogpost {
	objectId?: number;
	reason?: string | undefined;

	constructor(data?: ICommandOfBlogpost) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.objectId = _data["objectId"];
			this.reason = _data["reason"];
		}
	}

	static fromJS(data: any): CommandOfBlogpost {
		data = typeof data === 'object' ? data : {};
		let result = new CommandOfBlogpost();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["objectId"] = this.objectId;
		data["reason"] = this.reason;
		return data;
	}
}

export interface ICommandOfBlogpost {
	objectId?: number;
	reason?: string | undefined;
}

export class GetJoinedClubsResponse implements IGetJoinedClubsResponse {
	id?: number;
	name?: string | undefined;
	icon?: string | undefined;

	constructor(data?: IGetJoinedClubsResponse) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.icon = _data["icon"];
		}
	}

	static fromJS(data: any): GetJoinedClubsResponse {
		data = typeof data === 'object' ? data : {};
		let result = new GetJoinedClubsResponse();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["icon"] = this.icon;
		return data;
	}
}

export interface IGetJoinedClubsResponse {
	id?: number;
	name?: string | undefined;
	icon?: string | undefined;
}

export class GetClubsWithStoryResult implements IGetClubsWithStoryResult {
	id?: number;
	name?: string | undefined;
	icon?: string | undefined;

	constructor(data?: IGetClubsWithStoryResult) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.icon = _data["icon"];
		}
	}

	static fromJS(data: any): GetClubsWithStoryResult {
		data = typeof data === 'object' ? data : {};
		let result = new GetClubsWithStoryResult();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["icon"] = this.icon;
		return data;
	}
}

export interface IGetClubsWithStoryResult {
	id?: number;
	name?: string | undefined;
	icon?: string | undefined;
}

export class JoinClubCommand implements IJoinClubCommand {
	clubId?: number;

	constructor(data?: IJoinClubCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.clubId = _data["clubId"];
		}
	}

	static fromJS(data: any): JoinClubCommand {
		data = typeof data === 'object' ? data : {};
		let result = new JoinClubCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["clubId"] = this.clubId;
		return data;
	}
}

export interface IJoinClubCommand {
	clubId?: number;
}

export class LeaveClubCommand implements ILeaveClubCommand {
	clubId?: number;

	constructor(data?: ILeaveClubCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.clubId = _data["clubId"];
		}
	}

	static fromJS(data: any): LeaveClubCommand {
		data = typeof data === 'object' ? data : {};
		let result = new LeaveClubCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["clubId"] = this.clubId;
		return data;
	}
}

export interface ILeaveClubCommand {
	clubId?: number;
}

export class MarkChapterAsReadResponse implements IMarkChapterAsReadResponse {
	read?: number[] | undefined;

	constructor(data?: IMarkChapterAsReadResponse) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			if (Array.isArray(_data["read"])) {
				this.read = [] as any;
				for (let item of _data["read"])
					this.read!.push(item);
			}
		}
	}

	static fromJS(data: any): MarkChapterAsReadResponse {
		data = typeof data === 'object' ? data : {};
		let result = new MarkChapterAsReadResponse();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		if (Array.isArray(this.read)) {
			data["read"] = [];
			for (let item of this.read)
				data["read"].push(item);
		}
		return data;
	}
}

export interface IMarkChapterAsReadResponse {
	read?: number[] | undefined;
}

export class MarkChapterAsReadCommand implements IMarkChapterAsReadCommand {
	chapter?: number;
	story?: number;

	constructor(data?: IMarkChapterAsReadCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.chapter = _data["chapter"];
			this.story = _data["story"];
		}
	}

	static fromJS(data: any): MarkChapterAsReadCommand {
		data = typeof data === 'object' ? data : {};
		let result = new MarkChapterAsReadCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["chapter"] = this.chapter;
		data["story"] = this.story;
		return data;
	}
}

export interface IMarkChapterAsReadCommand {
	chapter?: number;
	story?: number;
}

export class MarkChapterAsUnreadResponse implements IMarkChapterAsUnreadResponse {
	read?: number[] | undefined;

	constructor(data?: IMarkChapterAsUnreadResponse) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			if (Array.isArray(_data["read"])) {
				this.read = [] as any;
				for (let item of _data["read"])
					this.read!.push(item);
			}
		}
	}

	static fromJS(data: any): MarkChapterAsUnreadResponse {
		data = typeof data === 'object' ? data : {};
		let result = new MarkChapterAsUnreadResponse();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		if (Array.isArray(this.read)) {
			data["read"] = [];
			for (let item of this.read)
				data["read"].push(item);
		}
		return data;
	}
}

export interface IMarkChapterAsUnreadResponse {
	read?: number[] | undefined;
}

export class MarkChapterAsUnreadCommand implements IMarkChapterAsUnreadCommand {
	chapter?: number;
	story?: number;

	constructor(data?: IMarkChapterAsUnreadCommand) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.chapter = _data["chapter"];
			this.story = _data["story"];
		}
	}

	static fromJS(data: any): MarkChapterAsUnreadCommand {
		data = typeof data === 'object' ? data : {};
		let result = new MarkChapterAsUnreadCommand();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["chapter"] = this.chapter;
		data["story"] = this.story;
		return data;
	}
}

export interface IMarkChapterAsUnreadCommand {
	chapter?: number;
	story?: number;
}

export interface FileParameter {
	data: any;
	fileName: string;
}

export interface FileResponse {
	data: Blob;
	status: number;
	fileName?: string;
	headers?: { [name: string]: any };
}

export class ApiException extends Error {
	message: string;
	status: number;
	response: string;
	headers: { [key: string]: any; };
	result: any;

	constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	protected isApiException = true;

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true;
	}
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
	if (result !== null && result !== undefined)
		throw result;
	else
		throw new ApiException(message, status, response, headers, null);
}