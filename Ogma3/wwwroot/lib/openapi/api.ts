/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * My Title
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost:5001".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiCommentsControllerPatchData
 */
export interface ApiCommentsControllerPatchData {
    /**
     * 
     * @type {string}
     * @memberof ApiCommentsControllerPatchData
     */
    body?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiCommentsControllerPatchData
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ApiCommentsControllerPostData
 */
export interface ApiCommentsControllerPostData {
    /**
     * 
     * @type {string}
     * @memberof ApiCommentsControllerPostData
     */
    body?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiCommentsControllerPostData
     */
    thread?: number;
}
/**
 * 
 * @export
 * @interface ApiCommentsThreadControllerPermissionsResult
 */
export interface ApiCommentsThreadControllerPermissionsResult {
    /**
     * 
     * @type {boolean}
     * @memberof ApiCommentsThreadControllerPermissionsResult
     */
    isSiteModerator?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiCommentsThreadControllerPermissionsResult
     */
    isClubModerator?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiCommentsThreadControllerPermissionsResult
     */
    isAllowed?: boolean;
}
/**
 * 
 * @export
 * @interface ApiCommentsThreadControllerPostData
 */
export interface ApiCommentsThreadControllerPostData {
    /**
     * 
     * @type {number}
     * @memberof ApiCommentsThreadControllerPostData
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ApiRatingsBody
 */
export interface ApiRatingsBody {
    /**
     * 
     * @type {number}
     * @memberof ApiRatingsBody
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiRatingsBody
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiRatingsBody
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiRatingsBody
     */
    blacklistedByDefault?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiRatingsBody
     */
    order?: number;
    /**
     * 
     * @type {Blob}
     * @memberof ApiRatingsBody
     */
    icon?: Blob;
}
/**
 * 
 * @export
 * @interface ApiRatingsBody1
 */
export interface ApiRatingsBody1 {
    /**
     * 
     * @type {string}
     * @memberof ApiRatingsBody1
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiRatingsBody1
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiRatingsBody1
     */
    blacklistedByDefault?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiRatingsBody1
     */
    order?: number;
    /**
     * 
     * @type {Blob}
     * @memberof ApiRatingsBody1
     */
    icon?: Blob;
}
/**
 * 
 * @export
 * @interface BanData
 */
export interface BanData {
    /**
     * 
     * @type {number}
     * @memberof BanData
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof BanData
     */
    days?: number;
}
/**
 * 
 * @export
 * @interface BaseModel
 */
export interface BaseModel {
    /**
     * 
     * @type {number}
     * @memberof BaseModel
     */
    id: number;
}
/**
 * 
 * @export
 * @interface BlacklistedRating
 */
export interface BlacklistedRating {
    /**
     * 
     * @type {OgmaUser}
     * @memberof BlacklistedRating
     */
    user?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof BlacklistedRating
     */
    userId?: number;
    /**
     * 
     * @type {Rating}
     * @memberof BlacklistedRating
     */
    rating?: Rating;
    /**
     * 
     * @type {number}
     * @memberof BlacklistedRating
     */
    ratingId?: number;
}
/**
 * 
 * @export
 * @interface BlacklistedTag
 */
export interface BlacklistedTag {
    /**
     * 
     * @type {OgmaUser}
     * @memberof BlacklistedTag
     */
    user?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof BlacklistedTag
     */
    userId?: number;
    /**
     * 
     * @type {Tag}
     * @memberof BlacklistedTag
     */
    tag?: Tag;
    /**
     * 
     * @type {number}
     * @memberof BlacklistedTag
     */
    tagId?: number;
}
/**
 * 
 * @export
 * @interface BlockPostData
 */
export interface BlockPostData {
    /**
     * 
     * @type {string}
     * @memberof BlockPostData
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Blogpost
 */
export interface Blogpost extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Blogpost
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Blogpost
     */
    slug?: string;
    /**
     * 
     * @type {Date}
     * @memberof Blogpost
     */
    publicationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Blogpost
     */
    creationDate?: Date;
    /**
     * 
     * @type {OgmaUser}
     * @memberof Blogpost
     */
    author?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof Blogpost
     */
    authorId?: number;
    /**
     * 
     * @type {string}
     * @memberof Blogpost
     */
    body?: string;
    /**
     * 
     * @type {CommentsThread}
     * @memberof Blogpost
     */
    commentsThread?: CommentsThread;
    /**
     * 
     * @type {number}
     * @memberof Blogpost
     */
    wordCount?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Blogpost
     */
    hashtags?: Array<string>;
    /**
     * 
     * @type {Story}
     * @memberof Blogpost
     */
    attachedStory?: Story;
    /**
     * 
     * @type {number}
     * @memberof Blogpost
     */
    attachedStoryId?: number;
    /**
     * 
     * @type {Chapter}
     * @memberof Blogpost
     */
    attachedChapter?: Chapter;
    /**
     * 
     * @type {number}
     * @memberof Blogpost
     */
    attachedChapterId?: number;
    /**
     * 
     * @type {ContentBlock}
     * @memberof Blogpost
     */
    contentBlock?: ContentBlock;
    /**
     * 
     * @type {number}
     * @memberof Blogpost
     */
    contentBlockId?: number;
    /**
     * 
     * @type {Array<Report>}
     * @memberof Blogpost
     */
    reports?: Array<Report>;
}
/**
 * 
 * @export
 * @interface Chapter
 */
export interface Chapter extends BaseModel {
    /**
     * 
     * @type {number}
     * @memberof Chapter
     */
    order?: number;
    /**
     * 
     * @type {Date}
     * @memberof Chapter
     */
    creationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Chapter
     */
    publicationDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    startNotes?: string;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    endNotes?: string;
    /**
     * 
     * @type {number}
     * @memberof Chapter
     */
    wordCount?: number;
    /**
     * 
     * @type {CommentsThread}
     * @memberof Chapter
     */
    commentsThread?: CommentsThread;
    /**
     * 
     * @type {Story}
     * @memberof Chapter
     */
    story?: Story;
    /**
     * 
     * @type {number}
     * @memberof Chapter
     */
    storyId?: number;
    /**
     * 
     * @type {ContentBlock}
     * @memberof Chapter
     */
    contentBlock?: ContentBlock;
    /**
     * 
     * @type {number}
     * @memberof Chapter
     */
    contentBlockId?: number;
    /**
     * 
     * @type {Array<Report>}
     * @memberof Chapter
     */
    reports?: Array<Report>;
}
/**
 * 
 * @export
 * @interface ChaptersReadsMarkChapterAsReadCommand
 */
export interface ChaptersReadsMarkChapterAsReadCommand {
    /**
     * 
     * @type {number}
     * @memberof ChaptersReadsMarkChapterAsReadCommand
     */
    chapter?: number;
    /**
     * 
     * @type {number}
     * @memberof ChaptersReadsMarkChapterAsReadCommand
     */
    story?: number;
}
/**
 * 
 * @export
 * @interface ChaptersReadsMarkChapterAsUnreadCommand
 */
export interface ChaptersReadsMarkChapterAsUnreadCommand {
    /**
     * 
     * @type {number}
     * @memberof ChaptersReadsMarkChapterAsUnreadCommand
     */
    chapter?: number;
    /**
     * 
     * @type {number}
     * @memberof ChaptersReadsMarkChapterAsUnreadCommand
     */
    story?: number;
}
/**
 * 
 * @export
 * @interface Club
 */
export interface Club extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Club
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Club
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Club
     */
    hook?: string;
    /**
     * 
     * @type {string}
     * @memberof Club
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Club
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof Club
     */
    iconId?: string;
    /**
     * 
     * @type {Date}
     * @memberof Club
     */
    creationDate?: Date;
    /**
     * 
     * @type {Array<ClubMember>}
     * @memberof Club
     */
    clubMembers?: Array<ClubMember>;
    /**
     * 
     * @type {Array<ClubThread>}
     * @memberof Club
     */
    threads?: Array<ClubThread>;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof Club
     */
    folders?: Array<Folder>;
    /**
     * 
     * @type {Array<Report>}
     * @memberof Club
     */
    reports?: Array<Report>;
}
/**
 * 
 * @export
 * @interface ClubJoinJoinClubCommand
 */
export interface ClubJoinJoinClubCommand {
    /**
     * 
     * @type {number}
     * @memberof ClubJoinJoinClubCommand
     */
    clubId?: number;
}
/**
 * 
 * @export
 * @interface ClubJoinLeaveClubCommand
 */
export interface ClubJoinLeaveClubCommand {
    /**
     * 
     * @type {number}
     * @memberof ClubJoinLeaveClubCommand
     */
    clubId?: number;
}
/**
 * 
 * @export
 * @interface ClubMember
 */
export interface ClubMember {
    /**
     * 
     * @type {OgmaUser}
     * @memberof ClubMember
     */
    member?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof ClubMember
     */
    memberId?: number;
    /**
     * 
     * @type {Club}
     * @memberof ClubMember
     */
    club?: Club;
    /**
     * 
     * @type {number}
     * @memberof ClubMember
     */
    clubId?: number;
    /**
     * 
     * @type {EClubMemberRoles}
     * @memberof ClubMember
     */
    role?: EClubMemberRoles;
    /**
     * 
     * @type {Date}
     * @memberof ClubMember
     */
    memberSince?: Date;
}
/**
 * 
 * @export
 * @interface ClubThread
 */
export interface ClubThread extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof ClubThread
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ClubThread
     */
    body?: string;
    /**
     * 
     * @type {OgmaUser}
     * @memberof ClubThread
     */
    author?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof ClubThread
     */
    authorId?: number;
    /**
     * 
     * @type {Date}
     * @memberof ClubThread
     */
    creationDate?: Date;
    /**
     * 
     * @type {CommentsThread}
     * @memberof ClubThread
     */
    commentsThread?: CommentsThread;
    /**
     * 
     * @type {Club}
     * @memberof ClubThread
     */
    club?: Club;
    /**
     * 
     * @type {number}
     * @memberof ClubThread
     */
    clubId?: number;
    /**
     * 
     * @type {Date}
     * @memberof ClubThread
     */
    deletedAt?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof ClubThread
     */
    isPinned?: boolean;
}
/**
 * 
 * @export
 * @interface ClubsGetClubsWithStoryResult
 */
export interface ClubsGetClubsWithStoryResult {
    /**
     * 
     * @type {number}
     * @memberof ClubsGetClubsWithStoryResult
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ClubsGetClubsWithStoryResult
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ClubsGetClubsWithStoryResult
     */
    icon?: string;
}
/**
 * 
 * @export
 * @interface ClubsGetJoinedClubsResponse
 */
export interface ClubsGetJoinedClubsResponse {
    /**
     * 
     * @type {number}
     * @memberof ClubsGetJoinedClubsResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ClubsGetJoinedClubsResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ClubsGetJoinedClubsResponse
     */
    icon?: string;
}
/**
 * 
 * @export
 * @interface CommandOfBlogpost
 */
export interface CommandOfBlogpost {
    /**
     * 
     * @type {number}
     * @memberof CommandOfBlogpost
     */
    objectId?: number;
    /**
     * 
     * @type {string}
     * @memberof CommandOfBlogpost
     */
    reason?: string;
}
/**
 * 
 * @export
 * @interface CommandOfChapter
 */
export interface CommandOfChapter {
    /**
     * 
     * @type {number}
     * @memberof CommandOfChapter
     */
    objectId?: number;
    /**
     * 
     * @type {string}
     * @memberof CommandOfChapter
     */
    reason?: string;
}
/**
 * 
 * @export
 * @interface CommandOfStory
 */
export interface CommandOfStory {
    /**
     * 
     * @type {number}
     * @memberof CommandOfStory
     */
    objectId?: number;
    /**
     * 
     * @type {string}
     * @memberof CommandOfStory
     */
    reason?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment extends BaseModel {
    /**
     * 
     * @type {CommentsThread}
     * @memberof Comment
     */
    commentsThread?: CommentsThread;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    commentsThreadId?: number;
    /**
     * 
     * @type {OgmaUser}
     * @memberof Comment
     */
    author?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    authorId?: number;
    /**
     * 
     * @type {Date}
     * @memberof Comment
     */
    dateTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Comment
     */
    lastEdit?: Date;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    body?: string;
    /**
     * 
     * @type {EDeletedBy}
     * @memberof Comment
     */
    deletedBy?: EDeletedBy;
    /**
     * 
     * @type {OgmaUser}
     * @memberof Comment
     */
    deletedByUser?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    deletedByUserId?: number;
    /**
     * 
     * @type {Array<CommentRevision>}
     * @memberof Comment
     */
    revisions?: Array<CommentRevision>;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    editCount?: number;
    /**
     * 
     * @type {Array<Report>}
     * @memberof Comment
     */
    reports?: Array<Report>;
}
/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * 
     * @type {number}
     * @memberof CommentDto
     */
    id?: number;
    /**
     * 
     * @type {UserSimpleDto}
     * @memberof CommentDto
     */
    author?: UserSimpleDto;
    /**
     * 
     * @type {Date}
     * @memberof CommentDto
     */
    dateTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CommentDto
     */
    lastEdit?: Date;
    /**
     * 
     * @type {number}
     * @memberof CommentDto
     */
    editCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CommentDto
     */
    owned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CommentDto
     */
    body?: string;
    /**
     * 
     * @type {EDeletedBy}
     * @memberof CommentDto
     */
    deletedBy?: EDeletedBy;
    /**
     * 
     * @type {boolean}
     * @memberof CommentDto
     */
    isBlocked?: boolean;
}
/**
 * 
 * @export
 * @interface CommentRevision
 */
export interface CommentRevision extends BaseModel {
    /**
     * 
     * @type {Date}
     * @memberof CommentRevision
     */
    editTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof CommentRevision
     */
    body?: string;
    /**
     * 
     * @type {Comment}
     * @memberof CommentRevision
     */
    parent?: Comment;
    /**
     * 
     * @type {number}
     * @memberof CommentRevision
     */
    parentId?: number;
}
/**
 * 
 * @export
 * @interface CommentRevisionDto
 */
export interface CommentRevisionDto {
    /**
     * 
     * @type {Date}
     * @memberof CommentRevisionDto
     */
    editTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof CommentRevisionDto
     */
    body?: string;
}
/**
 * 
 * @export
 * @interface CommentsThread
 */
export interface CommentsThread extends BaseModel {
    /**
     * 
     * @type {Array<Comment>}
     * @memberof CommentsThread
     */
    comments?: Array<Comment>;
    /**
     * 
     * @type {number}
     * @memberof CommentsThread
     */
    commentsCount?: number;
    /**
     * 
     * @type {Date}
     * @memberof CommentsThread
     */
    lockDate?: Date;
    /**
     * 
     * @type {OgmaUser}
     * @memberof CommentsThread
     */
    user?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof CommentsThread
     */
    userId?: number;
    /**
     * 
     * @type {Chapter}
     * @memberof CommentsThread
     */
    chapter?: Chapter;
    /**
     * 
     * @type {number}
     * @memberof CommentsThread
     */
    chapterId?: number;
    /**
     * 
     * @type {Blogpost}
     * @memberof CommentsThread
     */
    blogpost?: Blogpost;
    /**
     * 
     * @type {number}
     * @memberof CommentsThread
     */
    blogpostId?: number;
    /**
     * 
     * @type {ClubThread}
     * @memberof CommentsThread
     */
    clubThread?: ClubThread;
    /**
     * 
     * @type {number}
     * @memberof CommentsThread
     */
    clubThreadId?: number;
    /**
     * 
     * @type {Array<OgmaUser>}
     * @memberof CommentsThread
     */
    subscribers?: Array<OgmaUser>;
}
/**
 * 
 * @export
 * @interface ContentBlock
 */
export interface ContentBlock extends BaseModel {
    /**
     * 
     * @type {OgmaUser}
     * @memberof ContentBlock
     */
    issuer?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof ContentBlock
     */
    issuerId?: number;
    /**
     * 
     * @type {string}
     * @memberof ContentBlock
     */
    reason?: string;
    /**
     * 
     * @type {Date}
     * @memberof ContentBlock
     */
    dateTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof ContentBlock
     */
    type?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EClubMemberRoles {
    Founder = <any> 'Founder',
    Admin = <any> 'Admin',
    Moderator = <any> 'Moderator',
    User = <any> 'User'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EDeletedBy {
    User = <any> 'User',
    Staff = <any> 'Staff'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ENotificationEvent {
    System = <any> 'System',
    WatchedStoryUpdated = <any> 'WatchedStoryUpdated',
    WatchedThreadNewComment = <any> 'WatchedThreadNewComment',
    FollowedAuthorNewBlogpost = <any> 'FollowedAuthorNewBlogpost',
    FollowedAuthorNewStory = <any> 'FollowedAuthorNewStory',
    CommentReply = <any> 'CommentReply'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EReportableContentTypes {
    Comment = <any> 'Comment',
    User = <any> 'User',
    Story = <any> 'Story',
    Chapter = <any> 'Chapter',
    Blogpost = <any> 'Blogpost',
    Club = <any> 'Club'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EStoryStatus {
    InProgress = <any> 'InProgress',
    Completed = <any> 'Completed',
    OnHiatus = <any> 'OnHiatus',
    Cancelled = <any> 'Cancelled'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ETagNamespace {
    ContentWarning = <any> 'ContentWarning',
    Genre = <any> 'Genre',
    Franchise = <any> 'Franchise'
}
/**
 * 
 * @export
 * @interface Faq
 */
export interface Faq extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Faq
     */
    question?: string;
    /**
     * 
     * @type {string}
     * @memberof Faq
     */
    answer?: string;
    /**
     * 
     * @type {string}
     * @memberof Faq
     */
    answerRendered?: string;
}
/**
 * 
 * @export
 * @interface FaqsCreateFaqCommand
 */
export interface FaqsCreateFaqCommand {
    /**
     * 
     * @type {string}
     * @memberof FaqsCreateFaqCommand
     */
    question?: string;
    /**
     * 
     * @type {string}
     * @memberof FaqsCreateFaqCommand
     */
    answer?: string;
}
/**
 * 
 * @export
 * @interface FaqsUpdateFaqCommand
 */
export interface FaqsUpdateFaqCommand {
    /**
     * 
     * @type {number}
     * @memberof FaqsUpdateFaqCommand
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FaqsUpdateFaqCommand
     */
    question?: string;
    /**
     * 
     * @type {string}
     * @memberof FaqsUpdateFaqCommand
     */
    answer?: string;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    description?: string;
    /**
     * 
     * @type {Club}
     * @memberof Folder
     */
    club?: Club;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    clubId?: number;
    /**
     * 
     * @type {Folder}
     * @memberof Folder
     */
    parentFolder?: Folder;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    parentFolderId?: number;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof Folder
     */
    childFolders?: Array<Folder>;
    /**
     * 
     * @type {Array<Story>}
     * @memberof Folder
     */
    stories?: Array<Story>;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    storiesCount?: number;
    /**
     * 
     * @type {EClubMemberRoles}
     * @memberof Folder
     */
    accessLevel?: EClubMemberRoles;
}
/**
 * 
 * @export
 * @interface FolderStory
 */
export interface FolderStory {
    /**
     * 
     * @type {Folder}
     * @memberof FolderStory
     */
    folder?: Folder;
    /**
     * 
     * @type {number}
     * @memberof FolderStory
     */
    folderId?: number;
    /**
     * 
     * @type {Story}
     * @memberof FolderStory
     */
    story?: Story;
    /**
     * 
     * @type {number}
     * @memberof FolderStory
     */
    storyId?: number;
}
/**
 * 
 * @export
 * @interface FoldersAddStoryToFolderCommand
 */
export interface FoldersAddStoryToFolderCommand {
    /**
     * 
     * @type {number}
     * @memberof FoldersAddStoryToFolderCommand
     */
    folderId?: number;
    /**
     * 
     * @type {number}
     * @memberof FoldersAddStoryToFolderCommand
     */
    storyId?: number;
}
/**
 * 
 * @export
 * @interface FoldersGetFolderResult
 */
export interface FoldersGetFolderResult {
    /**
     * 
     * @type {number}
     * @memberof FoldersGetFolderResult
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoldersGetFolderResult
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FoldersGetFolderResult
     */
    slug?: string;
    /**
     * 
     * @type {number}
     * @memberof FoldersGetFolderResult
     */
    parentFolderId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FoldersGetFolderResult
     */
    canAdd?: boolean;
}
/**
 * 
 * @export
 * @interface Icon
 */
export interface Icon extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Icon
     */
    name?: string;
}
/**
 * Represents a role in the identity system
 * @export
 * @interface IdentityRoleOfLong
 */
export interface IdentityRoleOfLong {
    /**
     * Gets or sets the primary key for this role.
     * @type {number}
     * @memberof IdentityRoleOfLong
     */
    id?: number;
    /**
     * Gets or sets the name for this role.
     * @type {string}
     * @memberof IdentityRoleOfLong
     */
    name?: string;
    /**
     * Gets or sets the normalized name for this role.
     * @type {string}
     * @memberof IdentityRoleOfLong
     */
    normalizedName?: string;
    /**
     * A random value that should change whenever a role is persisted to the store
     * @type {string}
     * @memberof IdentityRoleOfLong
     */
    concurrencyStamp?: string;
}
/**
 * Represents a user in the identity system
 * @export
 * @interface IdentityUserOfLong
 */
export interface IdentityUserOfLong {
    /**
     * Gets or sets the primary key for this user.
     * @type {number}
     * @memberof IdentityUserOfLong
     */
    id?: number;
    /**
     * Gets or sets the user name for this user.
     * @type {string}
     * @memberof IdentityUserOfLong
     */
    userName?: string;
    /**
     * Gets or sets the normalized user name for this user.
     * @type {string}
     * @memberof IdentityUserOfLong
     */
    normalizedUserName?: string;
    /**
     * Gets or sets the email address for this user.
     * @type {string}
     * @memberof IdentityUserOfLong
     */
    email?: string;
    /**
     * Gets or sets the normalized email address for this user.
     * @type {string}
     * @memberof IdentityUserOfLong
     */
    normalizedEmail?: string;
    /**
     * Gets or sets a flag indicating if a user has confirmed their email address.
     * @type {boolean}
     * @memberof IdentityUserOfLong
     */
    emailConfirmed?: boolean;
    /**
     * Gets or sets a salted and hashed representation of the password for this user.
     * @type {string}
     * @memberof IdentityUserOfLong
     */
    passwordHash?: string;
    /**
     * A random value that must change whenever a users credentials change (password changed, login removed)
     * @type {string}
     * @memberof IdentityUserOfLong
     */
    securityStamp?: string;
    /**
     * A random value that must change whenever a user is persisted to the store
     * @type {string}
     * @memberof IdentityUserOfLong
     */
    concurrencyStamp?: string;
    /**
     * Gets or sets a telephone number for the user.
     * @type {string}
     * @memberof IdentityUserOfLong
     */
    phoneNumber?: string;
    /**
     * Gets or sets a flag indicating if a user has confirmed their telephone address.
     * @type {boolean}
     * @memberof IdentityUserOfLong
     */
    phoneNumberConfirmed?: boolean;
    /**
     * Gets or sets a flag indicating if two factor authentication is enabled for this user.
     * @type {boolean}
     * @memberof IdentityUserOfLong
     */
    twoFactorEnabled?: boolean;
    /**
     * Gets or sets the date and time, in UTC, when any user lockout ends.
     * @type {Date}
     * @memberof IdentityUserOfLong
     */
    lockoutEnd?: Date;
    /**
     * Gets or sets a flag indicating if the user could be locked out.
     * @type {boolean}
     * @memberof IdentityUserOfLong
     */
    lockoutEnabled?: boolean;
    /**
     * Gets or sets the number of failed login attempts for the current user.
     * @type {number}
     * @memberof IdentityUserOfLong
     */
    accessFailedCount?: number;
}
/**
 * Represents the link between a user and a role.
 * @export
 * @interface IdentityUserRoleOfLong
 */
export interface IdentityUserRoleOfLong {
    /**
     * Gets or sets the primary key of the user that is linked to a role.
     * @type {number}
     * @memberof IdentityUserRoleOfLong
     */
    userId?: number;
    /**
     * Gets or sets the primary key of the role that is linked to the user.
     * @type {number}
     * @memberof IdentityUserRoleOfLong
     */
    roleId?: number;
}
/**
 * 
 * @export
 * @interface InviteCodeDto
 */
export interface InviteCodeDto {
    /**
     * 
     * @type {number}
     * @memberof InviteCodeDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteCodeDto
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteCodeDto
     */
    normalizedCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteCodeDto
     */
    usedByUserName?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteCodeDto
     */
    issuedByUserName?: string;
    /**
     * 
     * @type {Date}
     * @memberof InviteCodeDto
     */
    issueDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InviteCodeDto
     */
    usedDate?: Date;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    url?: string;
    /**
     * 
     * @type {Date}
     * @memberof Notification
     */
    dateTime?: Date;
    /**
     * 
     * @type {ENotificationEvent}
     * @memberof Notification
     */
    event?: ENotificationEvent;
    /**
     * 
     * @type {Array<OgmaUser>}
     * @memberof Notification
     */
    recipients?: Array<OgmaUser>;
}
/**
 * 
 * @export
 * @interface NotificationsGetUserNotificationsResult
 */
export interface NotificationsGetUserNotificationsResult {
    /**
     * 
     * @type {number}
     * @memberof NotificationsGetUserNotificationsResult
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NotificationsGetUserNotificationsResult
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsGetUserNotificationsResult
     */
    url?: string;
    /**
     * 
     * @type {Date}
     * @memberof NotificationsGetUserNotificationsResult
     */
    dateTime?: Date;
    /**
     * 
     * @type {ENotificationEvent}
     * @memberof NotificationsGetUserNotificationsResult
     */
    event?: ENotificationEvent;
    /**
     * 
     * @type {string}
     * @memberof NotificationsGetUserNotificationsResult
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface OgmaRole
 */
export interface OgmaRole extends IdentityRoleOfLong {
    /**
     * 
     * @type {boolean}
     * @memberof OgmaRole
     */
    isStaff?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OgmaRole
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof OgmaRole
     */
    order?: number;
    /**
     * 
     * @type {Array<OgmaUser>}
     * @memberof OgmaRole
     */
    users?: Array<OgmaUser>;
}
/**
 * 
 * @export
 * @interface OgmaUser
 */
export interface OgmaUser extends IdentityUserOfLong {
    /**
     * 
     * @type {string}
     * @memberof OgmaUser
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof OgmaUser
     */
    bio?: string;
    /**
     * 
     * @type {string}
     * @memberof OgmaUser
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof OgmaUser
     */
    avatarId?: string;
    /**
     * 
     * @type {Date}
     * @memberof OgmaUser
     */
    registrationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof OgmaUser
     */
    lastActive?: Date;
    /**
     * 
     * @type {CommentsThread}
     * @memberof OgmaUser
     */
    commentsThread?: CommentsThread;
    /**
     * 
     * @type {Array<UserRole>}
     * @memberof OgmaUser
     */
    userRoles?: Array<UserRole>;
    /**
     * 
     * @type {Array<Story>}
     * @memberof OgmaUser
     */
    stories?: Array<Story>;
    /**
     * 
     * @type {Array<Blogpost>}
     * @memberof OgmaUser
     */
    blogposts?: Array<Blogpost>;
    /**
     * 
     * @type {Array<OgmaRole>}
     * @memberof OgmaUser
     */
    roles?: Array<OgmaRole>;
    /**
     * 
     * @type {Array<BlacklistedRating>}
     * @memberof OgmaUser
     */
    blacklistedRatings?: Array<BlacklistedRating>;
    /**
     * 
     * @type {Array<BlacklistedTag>}
     * @memberof OgmaUser
     */
    blacklistedTags?: Array<BlacklistedTag>;
    /**
     * 
     * @type {Array<OgmaUser>}
     * @memberof OgmaUser
     */
    blockedUsers?: Array<OgmaUser>;
    /**
     * 
     * @type {Array<OgmaUser>}
     * @memberof OgmaUser
     */
    blockedByUsers?: Array<OgmaUser>;
    /**
     * 
     * @type {Array<OgmaUser>}
     * @memberof OgmaUser
     */
    followers?: Array<OgmaUser>;
    /**
     * 
     * @type {Array<OgmaUser>}
     * @memberof OgmaUser
     */
    following?: Array<OgmaUser>;
    /**
     * 
     * @type {Array<CommentsThread>}
     * @memberof OgmaUser
     */
    subscribedThreads?: Array<CommentsThread>;
    /**
     * 
     * @type {Date}
     * @memberof OgmaUser
     */
    bannedUntil?: Date;
    /**
     * 
     * @type {Date}
     * @memberof OgmaUser
     */
    mutedUntil?: Date;
    /**
     * 
     * @type {Array<Report>}
     * @memberof OgmaUser
     */
    reports?: Array<Report>;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof OgmaUser
     */
    notifications?: Array<Notification>;
}
/**
 * 
 * @export
 * @interface PaginationResultOfCommentDto
 */
export interface PaginationResultOfCommentDto {
    /**
     * 
     * @type {Array<CommentDto>}
     * @memberof PaginationResultOfCommentDto
     */
    elements?: Array<CommentDto>;
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfCommentDto
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfCommentDto
     */
    perPage?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfCommentDto
     */
    pages?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfCommentDto
     */
    page?: number;
}
/**
 * 
 * @export
 * @interface Quote
 */
export interface Quote extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    author?: string;
}
/**
 * 
 * @export
 * @interface QuoteDto
 */
export interface QuoteDto {
    /**
     * 
     * @type {string}
     * @memberof QuoteDto
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteDto
     */
    author?: string;
}
/**
 * 
 * @export
 * @interface QuotesCreateQuoteCommand
 */
export interface QuotesCreateQuoteCommand {
    /**
     * 
     * @type {string}
     * @memberof QuotesCreateQuoteCommand
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof QuotesCreateQuoteCommand
     */
    author?: string;
}
/**
 * 
 * @export
 * @interface QuotesDeleteQuoteCommand
 */
export interface QuotesDeleteQuoteCommand {
    /**
     * 
     * @type {number}
     * @memberof QuotesDeleteQuoteCommand
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface QuotesUpdateQuoteCommand
 */
export interface QuotesUpdateQuoteCommand {
    /**
     * 
     * @type {number}
     * @memberof QuotesUpdateQuoteCommand
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof QuotesUpdateQuoteCommand
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof QuotesUpdateQuoteCommand
     */
    author?: string;
}
/**
 * 
 * @export
 * @interface Rating
 */
export interface Rating extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Rating
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Rating
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Rating
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof Rating
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof Rating
     */
    iconId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Rating
     */
    blacklistedByDefault?: boolean;
}
/**
 * 
 * @export
 * @interface RatingApiDto
 */
export interface RatingApiDto {
    /**
     * 
     * @type {number}
     * @memberof RatingApiDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RatingApiDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingApiDto
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof RatingApiDto
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof RatingApiDto
     */
    icon?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RatingApiDto
     */
    blacklistedByDefault?: boolean;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report extends BaseModel {
    /**
     * 
     * @type {OgmaUser}
     * @memberof Report
     */
    reporter?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    reporterId?: number;
    /**
     * 
     * @type {Date}
     * @memberof Report
     */
    reportDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    contentType?: string;
    /**
     * 
     * @type {Comment}
     * @memberof Report
     */
    comment?: Comment;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    commentId?: number;
    /**
     * 
     * @type {OgmaUser}
     * @memberof Report
     */
    user?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    userId?: number;
    /**
     * 
     * @type {Story}
     * @memberof Report
     */
    story?: Story;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    storyId?: number;
    /**
     * 
     * @type {Chapter}
     * @memberof Report
     */
    chapter?: Chapter;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    chapterId?: number;
    /**
     * 
     * @type {Blogpost}
     * @memberof Report
     */
    blogpost?: Blogpost;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    blogpostId?: number;
    /**
     * 
     * @type {Club}
     * @memberof Report
     */
    club?: Club;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    clubId?: number;
}
/**
 * 
 * @export
 * @interface ReportsReportContentCommand
 */
export interface ReportsReportContentCommand {
    /**
     * 
     * @type {number}
     * @memberof ReportsReportContentCommand
     */
    itemId?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportsReportContentCommand
     */
    reason?: string;
    /**
     * 
     * @type {EReportableContentTypes}
     * @memberof ReportsReportContentCommand
     */
    itemType?: EReportableContentTypes;
}
/**
 * 
 * @export
 * @interface RoleData
 */
export interface RoleData {
    /**
     * 
     * @type {number}
     * @memberof RoleData
     */
    userId?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof RoleData
     */
    roles?: Array<number>;
}
/**
 * 
 * @export
 * @interface RoleDto
 */
export interface RoleDto {
    /**
     * 
     * @type {number}
     * @memberof RoleDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RoleDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleDto
     */
    color?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDto
     */
    isStaff?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RoleDto
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface RolesCreateRoleCommand
 */
export interface RolesCreateRoleCommand {
    /**
     * 
     * @type {string}
     * @memberof RolesCreateRoleCommand
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RolesCreateRoleCommand
     */
    isStaff?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RolesCreateRoleCommand
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof RolesCreateRoleCommand
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface RolesUpdateRoleCommand
 */
export interface RolesUpdateRoleCommand {
    /**
     * 
     * @type {number}
     * @memberof RolesUpdateRoleCommand
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RolesUpdateRoleCommand
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RolesUpdateRoleCommand
     */
    isStaff?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RolesUpdateRoleCommand
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof RolesUpdateRoleCommand
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface Shelf
 */
export interface Shelf extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Shelf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Shelf
     */
    description?: string;
    /**
     * 
     * @type {OgmaUser}
     * @memberof Shelf
     */
    owner?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof Shelf
     */
    ownerId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Shelf
     */
    isDefault?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Shelf
     */
    isPublic?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Shelf
     */
    isQuickAdd?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Shelf
     */
    trackUpdates?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Shelf
     */
    color?: string;
    /**
     * 
     * @type {Icon}
     * @memberof Shelf
     */
    icon?: Icon;
    /**
     * 
     * @type {number}
     * @memberof Shelf
     */
    iconId?: number;
    /**
     * 
     * @type {Array<Story>}
     * @memberof Shelf
     */
    stories?: Array<Story>;
}
/**
 * 
 * @export
 * @interface ShelfDto
 */
export interface ShelfDto {
    /**
     * 
     * @type {number}
     * @memberof ShelfDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShelfDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShelfDto
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShelfDto
     */
    isDefault?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShelfDto
     */
    isPublic?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShelfDto
     */
    isQuickAdd?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShelfDto
     */
    trackUpdates?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShelfDto
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof ShelfDto
     */
    storiesCount?: number;
    /**
     * 
     * @type {string}
     * @memberof ShelfDto
     */
    iconName?: string;
    /**
     * 
     * @type {number}
     * @memberof ShelfDto
     */
    iconId?: number;
}
/**
 * 
 * @export
 * @interface ShelfStoriesAddBookToShelfResult
 */
export interface ShelfStoriesAddBookToShelfResult {
    /**
     * 
     * @type {number}
     * @memberof ShelfStoriesAddBookToShelfResult
     */
    shelfId?: number;
    /**
     * 
     * @type {number}
     * @memberof ShelfStoriesAddBookToShelfResult
     */
    storyId?: number;
}
/**
 * 
 * @export
 * @interface ShelfStoriesGetPaginatedUserShelvesResult
 */
export interface ShelfStoriesGetPaginatedUserShelvesResult {
    /**
     * 
     * @type {number}
     * @memberof ShelfStoriesGetPaginatedUserShelvesResult
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShelfStoriesGetPaginatedUserShelvesResult
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShelfStoriesGetPaginatedUserShelvesResult
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof ShelfStoriesGetPaginatedUserShelvesResult
     */
    iconName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShelfStoriesGetPaginatedUserShelvesResult
     */
    doesContainBook?: boolean;
}
/**
 * 
 * @export
 * @interface ShelfStoriesRemoveBookFromShelfResult
 */
export interface ShelfStoriesRemoveBookFromShelfResult {
    /**
     * 
     * @type {number}
     * @memberof ShelfStoriesRemoveBookFromShelfResult
     */
    shelfId?: number;
    /**
     * 
     * @type {number}
     * @memberof ShelfStoriesRemoveBookFromShelfResult
     */
    storyId?: number;
}
/**
 * 
 * @export
 * @interface ShelvesCreateShelfCommand
 */
export interface ShelvesCreateShelfCommand {
    /**
     * 
     * @type {string}
     * @memberof ShelvesCreateShelfCommand
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShelvesCreateShelfCommand
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShelvesCreateShelfCommand
     */
    isQuickAdd?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShelvesCreateShelfCommand
     */
    isPublic?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShelvesCreateShelfCommand
     */
    trackUpdates?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShelvesCreateShelfCommand
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof ShelvesCreateShelfCommand
     */
    icon?: number;
}
/**
 * 
 * @export
 * @interface ShelvesUpdateShelfCommand
 */
export interface ShelvesUpdateShelfCommand {
    /**
     * 
     * @type {number}
     * @memberof ShelvesUpdateShelfCommand
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShelvesUpdateShelfCommand
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShelvesUpdateShelfCommand
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShelvesUpdateShelfCommand
     */
    isQuickAdd?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShelvesUpdateShelfCommand
     */
    isPublic?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShelvesUpdateShelfCommand
     */
    trackUpdates?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShelvesUpdateShelfCommand
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof ShelvesUpdateShelfCommand
     */
    icon?: number;
}
/**
 * 
 * @export
 * @interface SignInGetSignInDataResult
 */
export interface SignInGetSignInDataResult {
    /**
     * 
     * @type {string}
     * @memberof SignInGetSignInDataResult
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof SignInGetSignInDataResult
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface Story
 */
export interface Story extends BaseModel {
    /**
     * 
     * @type {OgmaUser}
     * @memberof Story
     */
    author?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof Story
     */
    authorId?: number;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    hook?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    cover?: string;
    /**
     * 
     * @type {string}
     * @memberof Story
     */
    coverId?: string;
    /**
     * 
     * @type {Date}
     * @memberof Story
     */
    creationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Story
     */
    publicationDate?: Date;
    /**
     * 
     * @type {Array<Chapter>}
     * @memberof Story
     */
    chapters?: Array<Chapter>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Story
     */
    tags?: Array<Tag>;
    /**
     * 
     * @type {Array<Vote>}
     * @memberof Story
     */
    votes?: Array<Vote>;
    /**
     * 
     * @type {Rating}
     * @memberof Story
     */
    rating?: Rating;
    /**
     * 
     * @type {number}
     * @memberof Story
     */
    ratingId?: number;
    /**
     * 
     * @type {EStoryStatus}
     * @memberof Story
     */
    status?: EStoryStatus;
    /**
     * 
     * @type {number}
     * @memberof Story
     */
    wordCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Story
     */
    chapterCount?: number;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof Story
     */
    folders?: Array<Folder>;
    /**
     * 
     * @type {ContentBlock}
     * @memberof Story
     */
    contentBlock?: ContentBlock;
    /**
     * 
     * @type {number}
     * @memberof Story
     */
    contentBlockId?: number;
    /**
     * 
     * @type {Array<Report>}
     * @memberof Story
     */
    reports?: Array<Report>;
    /**
     * 
     * @type {Array<Shelf>}
     * @memberof Story
     */
    shelves?: Array<Shelf>;
}
/**
 * 
 * @export
 * @interface SubscriptionsSubscribeCommentsThreadCommand
 */
export interface SubscriptionsSubscribeCommentsThreadCommand {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsSubscribeCommentsThreadCommand
     */
    threadId?: number;
}
/**
 * 
 * @export
 * @interface SubscriptionsUnsubscribeCommentsThreadCommand
 */
export interface SubscriptionsUnsubscribeCommentsThreadCommand {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsUnsubscribeCommentsThreadCommand
     */
    threadId?: number;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag extends BaseModel {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    description?: string;
    /**
     * 
     * @type {ETagNamespace}
     * @memberof Tag
     */
    namespace?: ETagNamespace;
    /**
     * 
     * @type {Array<Story>}
     * @memberof Tag
     */
    stories?: Array<Story>;
}
/**
 * 
 * @export
 * @interface TagDto
 */
export interface TagDto {
    /**
     * 
     * @type {number}
     * @memberof TagDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TagDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagDto
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof TagDto
     */
    description?: string;
    /**
     * 
     * @type {ETagNamespace}
     * @memberof TagDto
     */
    namespace?: ETagNamespace;
    /**
     * 
     * @type {string}
     * @memberof TagDto
     */
    namespaceColor?: string;
    /**
     * 
     * @type {number}
     * @memberof TagDto
     */
    namespaceId?: number;
}
/**
 * 
 * @export
 * @interface TagsCreateTagCommand
 */
export interface TagsCreateTagCommand {
    /**
     * 
     * @type {string}
     * @memberof TagsCreateTagCommand
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagsCreateTagCommand
     */
    description?: string;
    /**
     * 
     * @type {ETagNamespace}
     * @memberof TagsCreateTagCommand
     */
    namespace?: ETagNamespace;
}
/**
 * 
 * @export
 * @interface TagsUpdateTagCommand
 */
export interface TagsUpdateTagCommand {
    /**
     * 
     * @type {number}
     * @memberof TagsUpdateTagCommand
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TagsUpdateTagCommand
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagsUpdateTagCommand
     */
    description?: string;
    /**
     * 
     * @type {ETagNamespace}
     * @memberof TagsUpdateTagCommand
     */
    namespace?: ETagNamespace;
}
/**
 * 
 * @export
 * @interface UserRole
 */
export interface UserRole extends IdentityUserRoleOfLong {
    /**
     * 
     * @type {OgmaUser}
     * @memberof UserRole
     */
    user: OgmaUser;
    /**
     * 
     * @type {OgmaRole}
     * @memberof UserRole
     */
    role: OgmaRole;
}
/**
 * 
 * @export
 * @interface UserSimpleDto
 */
export interface UserSimpleDto {
    /**
     * 
     * @type {string}
     * @memberof UserSimpleDto
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSimpleDto
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSimpleDto
     */
    title?: string;
    /**
     * 
     * @type {Array<RoleDto>}
     * @memberof UserSimpleDto
     */
    roles?: Array<RoleDto>;
}
/**
 * 
 * @export
 * @interface Vote
 */
export interface Vote extends BaseModel {
    /**
     * 
     * @type {OgmaUser}
     * @memberof Vote
     */
    user?: OgmaUser;
    /**
     * 
     * @type {number}
     * @memberof Vote
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof Vote
     */
    storyId?: number;
}
/**
 * 
 * @export
 * @interface VotesCreateVoteCommand
 */
export interface VotesCreateVoteCommand {
    /**
     * 
     * @type {number}
     * @memberof VotesCreateVoteCommand
     */
    storyId?: number;
}
/**
 * 
 * @export
 * @interface VotesCreateVoteResult
 */
export interface VotesCreateVoteResult {
    /**
     * 
     * @type {boolean}
     * @memberof VotesCreateVoteResult
     */
    didVote?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VotesCreateVoteResult
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface VotesDeleteVoteCommand
 */
export interface VotesDeleteVoteCommand {
    /**
     * 
     * @type {number}
     * @memberof VotesDeleteVoteCommand
     */
    storyId?: number;
}
/**
 * 
 * @export
 * @interface VotesDeleteVoteResult
 */
export interface VotesDeleteVoteResult {
    /**
     * 
     * @type {boolean}
     * @memberof VotesDeleteVoteResult
     */
    didVote?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VotesDeleteVoteResult
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface VotesGetVotesResult
 */
export interface VotesGetVotesResult {
    /**
     * 
     * @type {number}
     * @memberof VotesGetVotesResult
     */
    count?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VotesGetVotesResult
     */
    didVote?: boolean;
}
/**
 * ChaptersReadApi - fetch parameter creator
 * @export
 */
export const ChaptersReadApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChaptersReadsMarkChapterAsUnreadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chaptersReadDeleteChaptersRead(body: ChaptersReadsMarkChapterAsUnreadCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling chaptersReadDeleteChaptersRead.');
            }
            const localVarPath = `/api/chaptersread`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChaptersReadsMarkChapterAsUnreadCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} story 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chaptersReadGetChaptersRead(story: number, options: any = {}): FetchArgs {
            // verify required parameter 'story' is not null or undefined
            if (story === null || story === undefined) {
                throw new RequiredError('story','Required parameter story was null or undefined when calling chaptersReadGetChaptersRead.');
            }
            const localVarPath = `/api/chaptersread/{story}`
                .replace(`{${"story"}}`, encodeURIComponent(String(story)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChaptersReadsMarkChapterAsReadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chaptersReadPostChaptersRead(body: ChaptersReadsMarkChapterAsReadCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling chaptersReadPostChaptersRead.');
            }
            const localVarPath = `/api/chaptersread`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChaptersReadsMarkChapterAsReadCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChaptersReadApi - functional programming interface
 * @export
 */
export const ChaptersReadApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChaptersReadsMarkChapterAsUnreadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chaptersReadDeleteChaptersRead(body: ChaptersReadsMarkChapterAsUnreadCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ChaptersReadApiFetchParamCreator(configuration).chaptersReadDeleteChaptersRead(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} story 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chaptersReadGetChaptersRead(story: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = ChaptersReadApiFetchParamCreator(configuration).chaptersReadGetChaptersRead(story, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ChaptersReadsMarkChapterAsReadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chaptersReadPostChaptersRead(body: ChaptersReadsMarkChapterAsReadCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ChaptersReadApiFetchParamCreator(configuration).chaptersReadPostChaptersRead(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChaptersReadApi - factory interface
 * @export
 */
export const ChaptersReadApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ChaptersReadsMarkChapterAsUnreadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chaptersReadDeleteChaptersRead(body: ChaptersReadsMarkChapterAsUnreadCommand, options?: any) {
            return ChaptersReadApiFp(configuration).chaptersReadDeleteChaptersRead(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} story 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chaptersReadGetChaptersRead(story: number, options?: any) {
            return ChaptersReadApiFp(configuration).chaptersReadGetChaptersRead(story, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ChaptersReadsMarkChapterAsReadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chaptersReadPostChaptersRead(body: ChaptersReadsMarkChapterAsReadCommand, options?: any) {
            return ChaptersReadApiFp(configuration).chaptersReadPostChaptersRead(body, options)(fetch, basePath);
        },
    };
};

/**
 * ChaptersReadApi - object-oriented interface
 * @export
 * @class ChaptersReadApi
 * @extends {BaseAPI}
 */
export class ChaptersReadApi extends BaseAPI {
    /**
     * 
     * @param {ChaptersReadsMarkChapterAsUnreadCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChaptersReadApi
     */
    public chaptersReadDeleteChaptersRead(body: ChaptersReadsMarkChapterAsUnreadCommand, options?: any) {
        return ChaptersReadApiFp(this.configuration).chaptersReadDeleteChaptersRead(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} story 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChaptersReadApi
     */
    public chaptersReadGetChaptersRead(story: number, options?: any) {
        return ChaptersReadApiFp(this.configuration).chaptersReadGetChaptersRead(story, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ChaptersReadsMarkChapterAsReadCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChaptersReadApi
     */
    public chaptersReadPostChaptersRead(body: ChaptersReadsMarkChapterAsReadCommand, options?: any) {
        return ChaptersReadApiFp(this.configuration).chaptersReadPostChaptersRead(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ClubJoinApi - fetch parameter creator
 * @export
 */
export const ClubJoinApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} club 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubJoinCheckMembershipStatus(club: number, options: any = {}): FetchArgs {
            // verify required parameter 'club' is not null or undefined
            if (club === null || club === undefined) {
                throw new RequiredError('club','Required parameter club was null or undefined when calling clubJoinCheckMembershipStatus.');
            }
            const localVarPath = `/api/clubjoin/{club}`
                .replace(`{${"club"}}`, encodeURIComponent(String(club)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClubJoinJoinClubCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubJoinJoinClub(body: ClubJoinJoinClubCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling clubJoinJoinClub.');
            }
            const localVarPath = `/api/clubjoin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClubJoinJoinClubCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClubJoinLeaveClubCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubJoinLeaveClub(body: ClubJoinLeaveClubCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling clubJoinLeaveClub.');
            }
            const localVarPath = `/api/clubjoin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClubJoinLeaveClubCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubJoinApi - functional programming interface
 * @export
 */
export const ClubJoinApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} club 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubJoinCheckMembershipStatus(club: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ClubJoinApiFetchParamCreator(configuration).clubJoinCheckMembershipStatus(club, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ClubJoinJoinClubCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubJoinJoinClub(body: ClubJoinJoinClubCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ClubJoinApiFetchParamCreator(configuration).clubJoinJoinClub(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ClubJoinLeaveClubCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubJoinLeaveClub(body: ClubJoinLeaveClubCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ClubJoinApiFetchParamCreator(configuration).clubJoinLeaveClub(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClubJoinApi - factory interface
 * @export
 */
export const ClubJoinApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} club 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubJoinCheckMembershipStatus(club: number, options?: any) {
            return ClubJoinApiFp(configuration).clubJoinCheckMembershipStatus(club, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ClubJoinJoinClubCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubJoinJoinClub(body: ClubJoinJoinClubCommand, options?: any) {
            return ClubJoinApiFp(configuration).clubJoinJoinClub(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ClubJoinLeaveClubCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubJoinLeaveClub(body: ClubJoinLeaveClubCommand, options?: any) {
            return ClubJoinApiFp(configuration).clubJoinLeaveClub(body, options)(fetch, basePath);
        },
    };
};

/**
 * ClubJoinApi - object-oriented interface
 * @export
 * @class ClubJoinApi
 * @extends {BaseAPI}
 */
export class ClubJoinApi extends BaseAPI {
    /**
     * 
     * @param {number} club 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubJoinApi
     */
    public clubJoinCheckMembershipStatus(club: number, options?: any) {
        return ClubJoinApiFp(this.configuration).clubJoinCheckMembershipStatus(club, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ClubJoinJoinClubCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubJoinApi
     */
    public clubJoinJoinClub(body: ClubJoinJoinClubCommand, options?: any) {
        return ClubJoinApiFp(this.configuration).clubJoinJoinClub(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ClubJoinLeaveClubCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubJoinApi
     */
    public clubJoinLeaveClub(body: ClubJoinLeaveClubCommand, options?: any) {
        return ClubJoinApiFp(this.configuration).clubJoinLeaveClub(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ClubsApi - fetch parameter creator
 * @export
 */
export const ClubsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubsGetClubsWithStory(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling clubsGetClubsWithStory.');
            }
            const localVarPath = `/api/clubs/story/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubsGetUserClubs(options: any = {}): FetchArgs {
            const localVarPath = `/api/clubs/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubsPing(options: any = {}): FetchArgs {
            const localVarPath = `/api/clubs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubsApi - functional programming interface
 * @export
 */
export const ClubsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubsGetClubsWithStory(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClubsGetClubsWithStoryResult>> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).clubsGetClubsWithStory(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubsGetUserClubs(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClubsGetJoinedClubsResponse>> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).clubsGetUserClubs(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubsPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ClubsApiFetchParamCreator(configuration).clubsPing(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClubsApi - factory interface
 * @export
 */
export const ClubsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubsGetClubsWithStory(id: number, options?: any) {
            return ClubsApiFp(configuration).clubsGetClubsWithStory(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubsGetUserClubs(options?: any) {
            return ClubsApiFp(configuration).clubsGetUserClubs(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubsPing(options?: any) {
            return ClubsApiFp(configuration).clubsPing(options)(fetch, basePath);
        },
    };
};

/**
 * ClubsApi - object-oriented interface
 * @export
 * @class ClubsApi
 * @extends {BaseAPI}
 */
export class ClubsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public clubsGetClubsWithStory(id: number, options?: any) {
        return ClubsApiFp(this.configuration).clubsGetClubsWithStory(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public clubsGetUserClubs(options?: any) {
        return ClubsApiFp(this.configuration).clubsGetUserClubs(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public clubsPing(options?: any) {
        return ClubsApiFp(this.configuration).clubsPing(options)(this.fetch, this.basePath);
    }

}
/**
 * CommentsApi - fetch parameter creator
 * @export
 */
export const CommentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsDeleteComment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling commentsDeleteComment.');
            }
            const localVarPath = `/api/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetComment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling commentsGetComment.');
            }
            const localVarPath = `/api/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [thread] 
         * @param {number} [page] 
         * @param {number} [highlight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetComments(thread?: number, page?: number, highlight?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/comments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (thread !== undefined) {
                localVarQueryParameter['thread'] = thread;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (highlight !== undefined) {
                localVarQueryParameter['highlight'] = highlight;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetMarkdown(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/comments/md`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetRevisions(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling commentsGetRevisions.');
            }
            const localVarPath = `/api/comments/revisions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiCommentsControllerPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsPostComment(body: ApiCommentsControllerPostData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling commentsPostComment.');
            }
            const localVarPath = `/api/comments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApiCommentsControllerPostData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiCommentsControllerPatchData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsPutComment(body: ApiCommentsControllerPatchData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling commentsPutComment.');
            }
            const localVarPath = `/api/comments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApiCommentsControllerPatchData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsApi - functional programming interface
 * @export
 */
export const CommentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsDeleteComment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentDto> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).commentsDeleteComment(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetComment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentDto> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).commentsGetComment(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [thread] 
         * @param {number} [page] 
         * @param {number} [highlight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetComments(thread?: number, page?: number, highlight?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationResultOfCommentDto> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).commentsGetComments(thread, page, highlight, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetMarkdown(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).commentsGetMarkdown(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetRevisions(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CommentRevisionDto>> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).commentsGetRevisions(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ApiCommentsControllerPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsPostComment(body: ApiCommentsControllerPostData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentDto> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).commentsPostComment(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ApiCommentsControllerPatchData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsPutComment(body: ApiCommentsControllerPatchData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentDto> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).commentsPutComment(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommentsApi - factory interface
 * @export
 */
export const CommentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsDeleteComment(id: number, options?: any) {
            return CommentsApiFp(configuration).commentsDeleteComment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetComment(id: number, options?: any) {
            return CommentsApiFp(configuration).commentsGetComment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [thread] 
         * @param {number} [page] 
         * @param {number} [highlight] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetComments(thread?: number, page?: number, highlight?: number, options?: any) {
            return CommentsApiFp(configuration).commentsGetComments(thread, page, highlight, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetMarkdown(id?: number, options?: any) {
            return CommentsApiFp(configuration).commentsGetMarkdown(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetRevisions(id: number, options?: any) {
            return CommentsApiFp(configuration).commentsGetRevisions(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ApiCommentsControllerPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsPostComment(body: ApiCommentsControllerPostData, options?: any) {
            return CommentsApiFp(configuration).commentsPostComment(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ApiCommentsControllerPatchData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsPutComment(body: ApiCommentsControllerPatchData, options?: any) {
            return CommentsApiFp(configuration).commentsPutComment(body, options)(fetch, basePath);
        },
    };
};

/**
 * CommentsApi - object-oriented interface
 * @export
 * @class CommentsApi
 * @extends {BaseAPI}
 */
export class CommentsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsDeleteComment(id: number, options?: any) {
        return CommentsApiFp(this.configuration).commentsDeleteComment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsGetComment(id: number, options?: any) {
        return CommentsApiFp(this.configuration).commentsGetComment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [thread] 
     * @param {number} [page] 
     * @param {number} [highlight] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsGetComments(thread?: number, page?: number, highlight?: number, options?: any) {
        return CommentsApiFp(this.configuration).commentsGetComments(thread, page, highlight, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsGetMarkdown(id?: number, options?: any) {
        return CommentsApiFp(this.configuration).commentsGetMarkdown(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsGetRevisions(id: number, options?: any) {
        return CommentsApiFp(this.configuration).commentsGetRevisions(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ApiCommentsControllerPostData} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsPostComment(body: ApiCommentsControllerPostData, options?: any) {
        return CommentsApiFp(this.configuration).commentsPostComment(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ApiCommentsControllerPatchData} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsPutComment(body: ApiCommentsControllerPatchData, options?: any) {
        return CommentsApiFp(this.configuration).commentsPutComment(body, options)(this.fetch, this.basePath);
    }

}
/**
 * CommentsThreadApi - fetch parameter creator
 * @export
 */
export const CommentsThreadApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadGetLockStatus(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling commentsThreadGetLockStatus.');
            }
            const localVarPath = `/api/commentsthread/lock/status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadGetPermissions(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling commentsThreadGetPermissions.');
            }
            const localVarPath = `/api/commentsthread/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiCommentsThreadControllerPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadLockThread(body: ApiCommentsThreadControllerPostData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling commentsThreadLockThread.');
            }
            const localVarPath = `/api/commentsthread/lock`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApiCommentsThreadControllerPostData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadPing(options: any = {}): FetchArgs {
            const localVarPath = `/api/commentsthread`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsThreadApi - functional programming interface
 * @export
 */
export const CommentsThreadApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadGetLockStatus(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = CommentsThreadApiFetchParamCreator(configuration).commentsThreadGetLockStatus(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadGetPermissions(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCommentsThreadControllerPermissionsResult> {
            const localVarFetchArgs = CommentsThreadApiFetchParamCreator(configuration).commentsThreadGetPermissions(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ApiCommentsThreadControllerPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadLockThread(body: ApiCommentsThreadControllerPostData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = CommentsThreadApiFetchParamCreator(configuration).commentsThreadLockThread(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CommentsThreadApiFetchParamCreator(configuration).commentsThreadPing(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommentsThreadApi - factory interface
 * @export
 */
export const CommentsThreadApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadGetLockStatus(id: number, options?: any) {
            return CommentsThreadApiFp(configuration).commentsThreadGetLockStatus(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadGetPermissions(id: number, options?: any) {
            return CommentsThreadApiFp(configuration).commentsThreadGetPermissions(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ApiCommentsThreadControllerPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadLockThread(body: ApiCommentsThreadControllerPostData, options?: any) {
            return CommentsThreadApiFp(configuration).commentsThreadLockThread(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsThreadPing(options?: any) {
            return CommentsThreadApiFp(configuration).commentsThreadPing(options)(fetch, basePath);
        },
    };
};

/**
 * CommentsThreadApi - object-oriented interface
 * @export
 * @class CommentsThreadApi
 * @extends {BaseAPI}
 */
export class CommentsThreadApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsThreadApi
     */
    public commentsThreadGetLockStatus(id: number, options?: any) {
        return CommentsThreadApiFp(this.configuration).commentsThreadGetLockStatus(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsThreadApi
     */
    public commentsThreadGetPermissions(id: number, options?: any) {
        return CommentsThreadApiFp(this.configuration).commentsThreadGetPermissions(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ApiCommentsThreadControllerPostData} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsThreadApi
     */
    public commentsThreadLockThread(body: ApiCommentsThreadControllerPostData, options?: any) {
        return CommentsThreadApiFp(this.configuration).commentsThreadLockThread(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsThreadApi
     */
    public commentsThreadPing(options?: any) {
        return CommentsThreadApiFp(this.configuration).commentsThreadPing(options)(this.fetch, this.basePath);
    }

}
/**
 * ContentBlockApi - fetch parameter creator
 * @export
 */
export const ContentBlockApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CommandOfBlogpost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockBlockBlogpost(body: CommandOfBlogpost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentBlockBlockBlogpost.');
            }
            const localVarPath = `/api/contentblock/blogpost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommandOfBlogpost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CommandOfChapter} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockBlockChapter(body: CommandOfChapter, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentBlockBlockChapter.');
            }
            const localVarPath = `/api/contentblock/chapter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommandOfChapter" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CommandOfStory} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockBlockStory(body: CommandOfStory, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentBlockBlockStory.');
            }
            const localVarPath = `/api/contentblock/story`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommandOfStory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockPing(options: any = {}): FetchArgs {
            const localVarPath = `/api/contentblock`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentBlockApi - functional programming interface
 * @export
 */
export const ContentBlockApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CommandOfBlogpost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockBlockBlogpost(body: CommandOfBlogpost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ContentBlockApiFetchParamCreator(configuration).contentBlockBlockBlogpost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CommandOfChapter} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockBlockChapter(body: CommandOfChapter, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ContentBlockApiFetchParamCreator(configuration).contentBlockBlockChapter(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CommandOfStory} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockBlockStory(body: CommandOfStory, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ContentBlockApiFetchParamCreator(configuration).contentBlockBlockStory(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ContentBlockApiFetchParamCreator(configuration).contentBlockPing(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContentBlockApi - factory interface
 * @export
 */
export const ContentBlockApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CommandOfBlogpost} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockBlockBlogpost(body: CommandOfBlogpost, options?: any) {
            return ContentBlockApiFp(configuration).contentBlockBlockBlogpost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CommandOfChapter} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockBlockChapter(body: CommandOfChapter, options?: any) {
            return ContentBlockApiFp(configuration).contentBlockBlockChapter(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CommandOfStory} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockBlockStory(body: CommandOfStory, options?: any) {
            return ContentBlockApiFp(configuration).contentBlockBlockStory(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBlockPing(options?: any) {
            return ContentBlockApiFp(configuration).contentBlockPing(options)(fetch, basePath);
        },
    };
};

/**
 * ContentBlockApi - object-oriented interface
 * @export
 * @class ContentBlockApi
 * @extends {BaseAPI}
 */
export class ContentBlockApi extends BaseAPI {
    /**
     * 
     * @param {CommandOfBlogpost} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentBlockApi
     */
    public contentBlockBlockBlogpost(body: CommandOfBlogpost, options?: any) {
        return ContentBlockApiFp(this.configuration).contentBlockBlockBlogpost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CommandOfChapter} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentBlockApi
     */
    public contentBlockBlockChapter(body: CommandOfChapter, options?: any) {
        return ContentBlockApiFp(this.configuration).contentBlockBlockChapter(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CommandOfStory} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentBlockApi
     */
    public contentBlockBlockStory(body: CommandOfStory, options?: any) {
        return ContentBlockApiFp(this.configuration).contentBlockBlockStory(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentBlockApi
     */
    public contentBlockPing(options?: any) {
        return ContentBlockApiFp(this.configuration).contentBlockPing(options)(this.fetch, this.basePath);
    }

}
/**
 * ErrorApi - fetch parameter creator
 * @export
 */
export const ErrorApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorOnGet(code?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ErrorApi - functional programming interface
 * @export
 */
export const ErrorApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorOnGet(code?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ErrorApiFetchParamCreator(configuration).errorOnGet(code, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ErrorApi - factory interface
 * @export
 */
export const ErrorApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorOnGet(code?: number, options?: any) {
            return ErrorApiFp(configuration).errorOnGet(code, options)(fetch, basePath);
        },
    };
};

/**
 * ErrorApi - object-oriented interface
 * @export
 * @class ErrorApi
 * @extends {BaseAPI}
 */
export class ErrorApi extends BaseAPI {
    /**
     * 
     * @param {number} [code] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorApi
     */
    public errorOnGet(code?: number, options?: any) {
        return ErrorApiFp(this.configuration).errorOnGet(code, options)(this.fetch, this.basePath);
    }

}
/**
 * FaqsApi - fetch parameter creator
 * @export
 */
export const FaqsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsDeleteFaq(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling faqsDeleteFaq.');
            }
            const localVarPath = `/api/faqs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsGetFaq(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling faqsGetFaq.');
            }
            const localVarPath = `/api/faqs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsGetFaqs(options: any = {}): FetchArgs {
            const localVarPath = `/api/faqs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FaqsCreateFaqCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsPostFaq(body: FaqsCreateFaqCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling faqsPostFaq.');
            }
            const localVarPath = `/api/faqs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FaqsCreateFaqCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FaqsUpdateFaqCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsPutFaq(body: FaqsUpdateFaqCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling faqsPutFaq.');
            }
            const localVarPath = `/api/faqs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FaqsUpdateFaqCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FaqsApi - functional programming interface
 * @export
 */
export const FaqsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsDeleteFaq(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = FaqsApiFetchParamCreator(configuration).faqsDeleteFaq(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsGetFaq(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
            const localVarFetchArgs = FaqsApiFetchParamCreator(configuration).faqsGetFaq(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsGetFaqs(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Faq>> {
            const localVarFetchArgs = FaqsApiFetchParamCreator(configuration).faqsGetFaqs(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FaqsCreateFaqCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsPostFaq(body: FaqsCreateFaqCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
            const localVarFetchArgs = FaqsApiFetchParamCreator(configuration).faqsPostFaq(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FaqsUpdateFaqCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsPutFaq(body: FaqsUpdateFaqCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = FaqsApiFetchParamCreator(configuration).faqsPutFaq(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FaqsApi - factory interface
 * @export
 */
export const FaqsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsDeleteFaq(id: number, options?: any) {
            return FaqsApiFp(configuration).faqsDeleteFaq(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsGetFaq(id: number, options?: any) {
            return FaqsApiFp(configuration).faqsGetFaq(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsGetFaqs(options?: any) {
            return FaqsApiFp(configuration).faqsGetFaqs(options)(fetch, basePath);
        },
        /**
         * 
         * @param {FaqsCreateFaqCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsPostFaq(body: FaqsCreateFaqCommand, options?: any) {
            return FaqsApiFp(configuration).faqsPostFaq(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {FaqsUpdateFaqCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsPutFaq(body: FaqsUpdateFaqCommand, options?: any) {
            return FaqsApiFp(configuration).faqsPutFaq(body, options)(fetch, basePath);
        },
    };
};

/**
 * FaqsApi - object-oriented interface
 * @export
 * @class FaqsApi
 * @extends {BaseAPI}
 */
export class FaqsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaqsApi
     */
    public faqsDeleteFaq(id: number, options?: any) {
        return FaqsApiFp(this.configuration).faqsDeleteFaq(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaqsApi
     */
    public faqsGetFaq(id: number, options?: any) {
        return FaqsApiFp(this.configuration).faqsGetFaq(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaqsApi
     */
    public faqsGetFaqs(options?: any) {
        return FaqsApiFp(this.configuration).faqsGetFaqs(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FaqsCreateFaqCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaqsApi
     */
    public faqsPostFaq(body: FaqsCreateFaqCommand, options?: any) {
        return FaqsApiFp(this.configuration).faqsPostFaq(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FaqsUpdateFaqCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaqsApi
     */
    public faqsPutFaq(body: FaqsUpdateFaqCommand, options?: any) {
        return FaqsApiFp(this.configuration).faqsPutFaq(body, options)(this.fetch, this.basePath);
    }

}
/**
 * FoldersApi - fetch parameter creator
 * @export
 */
export const FoldersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FoldersAddStoryToFolderCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersAddStory(body: FoldersAddStoryToFolderCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling foldersAddStory.');
            }
            const localVarPath = `/api/folders/add-story`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FoldersAddStoryToFolderCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersGetFoldersOfClub(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling foldersGetFoldersOfClub.');
            }
            const localVarPath = `/api/folders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersPing(options: any = {}): FetchArgs {
            const localVarPath = `/api/folders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FoldersAddStoryToFolderCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersAddStory(body: FoldersAddStoryToFolderCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FolderStory> {
            const localVarFetchArgs = FoldersApiFetchParamCreator(configuration).foldersAddStory(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersGetFoldersOfClub(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FoldersGetFolderResult>> {
            const localVarFetchArgs = FoldersApiFetchParamCreator(configuration).foldersGetFoldersOfClub(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = FoldersApiFetchParamCreator(configuration).foldersPing(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {FoldersAddStoryToFolderCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersAddStory(body: FoldersAddStoryToFolderCommand, options?: any) {
            return FoldersApiFp(configuration).foldersAddStory(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersGetFoldersOfClub(id: number, options?: any) {
            return FoldersApiFp(configuration).foldersGetFoldersOfClub(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersPing(options?: any) {
            return FoldersApiFp(configuration).foldersPing(options)(fetch, basePath);
        },
    };
};

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * 
     * @param {FoldersAddStoryToFolderCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersAddStory(body: FoldersAddStoryToFolderCommand, options?: any) {
        return FoldersApiFp(this.configuration).foldersAddStory(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersGetFoldersOfClub(id: number, options?: any) {
        return FoldersApiFp(this.configuration).foldersGetFoldersOfClub(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersPing(options?: any) {
        return FoldersApiFp(this.configuration).foldersPing(options)(this.fetch, this.basePath);
    }

}
/**
 * InviteCodesApi - fetch parameter creator
 * @export
 */
export const InviteCodesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesDeleteInviteCode(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling inviteCodesDeleteInviteCode.');
            }
            const localVarPath = `/api/invitecodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesGetInviteCodes(options: any = {}): FetchArgs {
            const localVarPath = `/api/invitecodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesGetPaginatedInviteCodes(page?: number, perPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/invitecodes/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['PerPage'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesPostInviteCode(options: any = {}): FetchArgs {
            const localVarPath = `/api/invitecodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesPostInviteCodeNoLimit(options: any = {}): FetchArgs {
            const localVarPath = `/api/invitecodes/no-limit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteCodesApi - functional programming interface
 * @export
 */
export const InviteCodesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesDeleteInviteCode(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = InviteCodesApiFetchParamCreator(configuration).inviteCodesDeleteInviteCode(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesGetInviteCodes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InviteCodeDto>> {
            const localVarFetchArgs = InviteCodesApiFetchParamCreator(configuration).inviteCodesGetInviteCodes(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesGetPaginatedInviteCodes(page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InviteCodeDto>> {
            const localVarFetchArgs = InviteCodesApiFetchParamCreator(configuration).inviteCodesGetPaginatedInviteCodes(page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesPostInviteCode(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InviteCodeDto> {
            const localVarFetchArgs = InviteCodesApiFetchParamCreator(configuration).inviteCodesPostInviteCode(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesPostInviteCodeNoLimit(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InviteCodeDto> {
            const localVarFetchArgs = InviteCodesApiFetchParamCreator(configuration).inviteCodesPostInviteCodeNoLimit(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InviteCodesApi - factory interface
 * @export
 */
export const InviteCodesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesDeleteInviteCode(id: number, options?: any) {
            return InviteCodesApiFp(configuration).inviteCodesDeleteInviteCode(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesGetInviteCodes(options?: any) {
            return InviteCodesApiFp(configuration).inviteCodesGetInviteCodes(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesGetPaginatedInviteCodes(page?: number, perPage?: number, options?: any) {
            return InviteCodesApiFp(configuration).inviteCodesGetPaginatedInviteCodes(page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesPostInviteCode(options?: any) {
            return InviteCodesApiFp(configuration).inviteCodesPostInviteCode(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCodesPostInviteCodeNoLimit(options?: any) {
            return InviteCodesApiFp(configuration).inviteCodesPostInviteCodeNoLimit(options)(fetch, basePath);
        },
    };
};

/**
 * InviteCodesApi - object-oriented interface
 * @export
 * @class InviteCodesApi
 * @extends {BaseAPI}
 */
export class InviteCodesApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteCodesApi
     */
    public inviteCodesDeleteInviteCode(id: number, options?: any) {
        return InviteCodesApiFp(this.configuration).inviteCodesDeleteInviteCode(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteCodesApi
     */
    public inviteCodesGetInviteCodes(options?: any) {
        return InviteCodesApiFp(this.configuration).inviteCodesGetInviteCodes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteCodesApi
     */
    public inviteCodesGetPaginatedInviteCodes(page?: number, perPage?: number, options?: any) {
        return InviteCodesApiFp(this.configuration).inviteCodesGetPaginatedInviteCodes(page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteCodesApi
     */
    public inviteCodesPostInviteCode(options?: any) {
        return InviteCodesApiFp(this.configuration).inviteCodesPostInviteCode(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteCodesApi
     */
    public inviteCodesPostInviteCodeNoLimit(options?: any) {
        return InviteCodesApiFp(this.configuration).inviteCodesPostInviteCodeNoLimit(options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsApi - fetch parameter creator
 * @export
 */
export const NotificationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsCountUserNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/api/notifications/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling notificationsDelete.');
            }
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetUserNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/api/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsCountUserNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NotificationsApiFetchParamCreator(configuration).notificationsCountUserNotifications(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = NotificationsApiFetchParamCreator(configuration).notificationsDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetUserNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NotificationsGetUserNotificationsResult>> {
            const localVarFetchArgs = NotificationsApiFetchParamCreator(configuration).notificationsGetUserNotifications(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsCountUserNotifications(options?: any) {
            return NotificationsApiFp(configuration).notificationsCountUserNotifications(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDelete(id: number, options?: any) {
            return NotificationsApiFp(configuration).notificationsDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetUserNotifications(options?: any) {
            return NotificationsApiFp(configuration).notificationsGetUserNotifications(options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsCountUserNotifications(options?: any) {
        return NotificationsApiFp(this.configuration).notificationsCountUserNotifications(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsDelete(id: number, options?: any) {
        return NotificationsApiFp(this.configuration).notificationsDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsGetUserNotifications(options?: any) {
        return NotificationsApiFp(this.configuration).notificationsGetUserNotifications(options)(this.fetch, this.basePath);
    }

}
/**
 * QuotesApi - fetch parameter creator
 * @export
 */
export const QuotesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {QuotesDeleteQuoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesDeleteQuote(body: QuotesDeleteQuoteCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling quotesDeleteQuote.');
            }
            const localVarPath = `/api/quotes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuotesDeleteQuoteCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesGetQuote(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling quotesGetQuote.');
            }
            const localVarPath = `/api/quotes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesGetQuotes(options: any = {}): FetchArgs {
            const localVarPath = `/api/quotes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesGetRandomQuote(options: any = {}): FetchArgs {
            const localVarPath = `/api/quotes/random`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesPostJson(options: any = {}): FetchArgs {
            const localVarPath = `/api/quotes/json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuotesCreateQuoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesPostQuote(body: QuotesCreateQuoteCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling quotesPostQuote.');
            }
            const localVarPath = `/api/quotes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuotesCreateQuoteCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuotesUpdateQuoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesPutQuote(body: QuotesUpdateQuoteCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling quotesPutQuote.');
            }
            const localVarPath = `/api/quotes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuotesUpdateQuoteCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuotesApi - functional programming interface
 * @export
 */
export const QuotesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {QuotesDeleteQuoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesDeleteQuote(body: QuotesDeleteQuoteCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Quote> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).quotesDeleteQuote(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesGetQuote(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDto> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).quotesGetQuote(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesGetQuotes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Quote>> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).quotesGetQuotes(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesGetRandomQuote(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuoteDto> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).quotesGetRandomQuote(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesPostJson(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).quotesPostJson(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {QuotesCreateQuoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesPostQuote(body: QuotesCreateQuoteCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Quote> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).quotesPostQuote(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {QuotesUpdateQuoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesPutQuote(body: QuotesUpdateQuoteCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Quote> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).quotesPutQuote(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuotesApi - factory interface
 * @export
 */
export const QuotesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {QuotesDeleteQuoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesDeleteQuote(body: QuotesDeleteQuoteCommand, options?: any) {
            return QuotesApiFp(configuration).quotesDeleteQuote(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesGetQuote(id: number, options?: any) {
            return QuotesApiFp(configuration).quotesGetQuote(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesGetQuotes(options?: any) {
            return QuotesApiFp(configuration).quotesGetQuotes(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesGetRandomQuote(options?: any) {
            return QuotesApiFp(configuration).quotesGetRandomQuote(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesPostJson(options?: any) {
            return QuotesApiFp(configuration).quotesPostJson(options)(fetch, basePath);
        },
        /**
         * 
         * @param {QuotesCreateQuoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesPostQuote(body: QuotesCreateQuoteCommand, options?: any) {
            return QuotesApiFp(configuration).quotesPostQuote(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {QuotesUpdateQuoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesPutQuote(body: QuotesUpdateQuoteCommand, options?: any) {
            return QuotesApiFp(configuration).quotesPutQuote(body, options)(fetch, basePath);
        },
    };
};

/**
 * QuotesApi - object-oriented interface
 * @export
 * @class QuotesApi
 * @extends {BaseAPI}
 */
export class QuotesApi extends BaseAPI {
    /**
     * 
     * @param {QuotesDeleteQuoteCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public quotesDeleteQuote(body: QuotesDeleteQuoteCommand, options?: any) {
        return QuotesApiFp(this.configuration).quotesDeleteQuote(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public quotesGetQuote(id: number, options?: any) {
        return QuotesApiFp(this.configuration).quotesGetQuote(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public quotesGetQuotes(options?: any) {
        return QuotesApiFp(this.configuration).quotesGetQuotes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public quotesGetRandomQuote(options?: any) {
        return QuotesApiFp(this.configuration).quotesGetRandomQuote(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public quotesPostJson(options?: any) {
        return QuotesApiFp(this.configuration).quotesPostJson(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {QuotesCreateQuoteCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public quotesPostQuote(body: QuotesCreateQuoteCommand, options?: any) {
        return QuotesApiFp(this.configuration).quotesPostQuote(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {QuotesUpdateQuoteCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotesApi
     */
    public quotesPutQuote(body: QuotesUpdateQuoteCommand, options?: any) {
        return QuotesApiFp(this.configuration).quotesPutQuote(body, options)(this.fetch, this.basePath);
    }

}
/**
 * RatingsApi - fetch parameter creator
 * @export
 */
export const RatingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsDeleteRating(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling ratingsDeleteRating.');
            }
            const localVarPath = `/api/ratings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGetRating(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling ratingsGetRating.');
            }
            const localVarPath = `/api/ratings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGetRatings(options: any = {}): FetchArgs {
            const localVarPath = `/api/ratings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [blacklistedByDefault] 
         * @param {number} [order] 
         * @param {Blob} [icon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsPostRating(name?: string, description?: string, blacklistedByDefault?: boolean, order?: number, icon?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/api/ratings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarFormParams.set('Name', name as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('Description', description as any);
            }

            if (blacklistedByDefault !== undefined) {
                localVarFormParams.set('BlacklistedByDefault', blacklistedByDefault as any);
            }

            if (order !== undefined) {
                localVarFormParams.set('Order', order as any);
            }

            if (icon !== undefined) {
                localVarFormParams.set('Icon', icon as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [blacklistedByDefault] 
         * @param {number} [order] 
         * @param {Blob} [icon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsPutRating(id?: number, name?: string, description?: string, blacklistedByDefault?: boolean, order?: number, icon?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/api/ratings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (id !== undefined) {
                localVarFormParams.set('Id', id as any);
            }

            if (name !== undefined) {
                localVarFormParams.set('Name', name as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('Description', description as any);
            }

            if (blacklistedByDefault !== undefined) {
                localVarFormParams.set('BlacklistedByDefault', blacklistedByDefault as any);
            }

            if (order !== undefined) {
                localVarFormParams.set('Order', order as any);
            }

            if (icon !== undefined) {
                localVarFormParams.set('Icon', icon as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingsApi - functional programming interface
 * @export
 */
export const RatingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsDeleteRating(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).ratingsDeleteRating(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGetRating(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RatingApiDto> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).ratingsGetRating(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGetRatings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RatingApiDto>> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).ratingsGetRatings(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [blacklistedByDefault] 
         * @param {number} [order] 
         * @param {Blob} [icon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsPostRating(name?: string, description?: string, blacklistedByDefault?: boolean, order?: number, icon?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RatingApiDto> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).ratingsPostRating(name, description, blacklistedByDefault, order, icon, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [blacklistedByDefault] 
         * @param {number} [order] 
         * @param {Blob} [icon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsPutRating(id?: number, name?: string, description?: string, blacklistedByDefault?: boolean, order?: number, icon?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RatingApiDto> {
            const localVarFetchArgs = RatingsApiFetchParamCreator(configuration).ratingsPutRating(id, name, description, blacklistedByDefault, order, icon, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RatingsApi - factory interface
 * @export
 */
export const RatingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsDeleteRating(id: number, options?: any) {
            return RatingsApiFp(configuration).ratingsDeleteRating(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGetRating(id: number, options?: any) {
            return RatingsApiFp(configuration).ratingsGetRating(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGetRatings(options?: any) {
            return RatingsApiFp(configuration).ratingsGetRatings(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [blacklistedByDefault] 
         * @param {number} [order] 
         * @param {Blob} [icon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsPostRating(name?: string, description?: string, blacklistedByDefault?: boolean, order?: number, icon?: Blob, options?: any) {
            return RatingsApiFp(configuration).ratingsPostRating(name, description, blacklistedByDefault, order, icon, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [blacklistedByDefault] 
         * @param {number} [order] 
         * @param {Blob} [icon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsPutRating(id?: number, name?: string, description?: string, blacklistedByDefault?: boolean, order?: number, icon?: Blob, options?: any) {
            return RatingsApiFp(configuration).ratingsPutRating(id, name, description, blacklistedByDefault, order, icon, options)(fetch, basePath);
        },
    };
};

/**
 * RatingsApi - object-oriented interface
 * @export
 * @class RatingsApi
 * @extends {BaseAPI}
 */
export class RatingsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public ratingsDeleteRating(id: number, options?: any) {
        return RatingsApiFp(this.configuration).ratingsDeleteRating(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public ratingsGetRating(id: number, options?: any) {
        return RatingsApiFp(this.configuration).ratingsGetRating(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public ratingsGetRatings(options?: any) {
        return RatingsApiFp(this.configuration).ratingsGetRatings(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {boolean} [blacklistedByDefault] 
     * @param {number} [order] 
     * @param {Blob} [icon] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public ratingsPostRating(name?: string, description?: string, blacklistedByDefault?: boolean, order?: number, icon?: Blob, options?: any) {
        return RatingsApiFp(this.configuration).ratingsPostRating(name, description, blacklistedByDefault, order, icon, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [id] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {boolean} [blacklistedByDefault] 
     * @param {number} [order] 
     * @param {Blob} [icon] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public ratingsPutRating(id?: number, name?: string, description?: string, blacklistedByDefault?: boolean, order?: number, icon?: Blob, options?: any) {
        return RatingsApiFp(this.configuration).ratingsPutRating(id, name, description, blacklistedByDefault, order, icon, options)(this.fetch, this.basePath);
    }

}
/**
 * ReportsApi - fetch parameter creator
 * @export
 */
export const ReportsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPing(options: any = {}): FetchArgs {
            const localVarPath = `/api/reports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReportsReportContentCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPostReports(body: ReportsReportContentCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reportsPostReports.');
            }
            const localVarPath = `/api/reports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReportsReportContentCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).reportsPing(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ReportsReportContentCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPostReports(body: ReportsReportContentCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).reportsPostReports(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPing(options?: any) {
            return ReportsApiFp(configuration).reportsPing(options)(fetch, basePath);
        },
        /**
         * 
         * @param {ReportsReportContentCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPostReports(body: ReportsReportContentCommand, options?: any) {
            return ReportsApiFp(configuration).reportsPostReports(body, options)(fetch, basePath);
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsPing(options?: any) {
        return ReportsApiFp(this.configuration).reportsPing(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ReportsReportContentCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsPostReports(body: ReportsReportContentCommand, options?: any) {
        return ReportsApiFp(this.configuration).reportsPostReports(body, options)(this.fetch, this.basePath);
    }

}
/**
 * RolesApi - fetch parameter creator
 * @export
 */
export const RolesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesDeleteRole(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rolesDeleteRole.');
            }
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGetRole(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rolesGetRole.');
            }
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGetRoles(options: any = {}): FetchArgs {
            const localVarPath = `/api/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolesCreateRoleCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPostRole(body: RolesCreateRoleCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolesPostRole.');
            }
            const localVarPath = `/api/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolesCreateRoleCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolesUpdateRoleCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPutRole(body: RolesUpdateRoleCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolesPutRole.');
            }
            const localVarPath = `/api/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolesUpdateRoleCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesDeleteRole(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).rolesDeleteRole(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGetRole(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleDto> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).rolesGetRole(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGetRoles(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoleDto>> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).rolesGetRoles(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolesCreateRoleCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPostRole(body: RolesCreateRoleCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleDto> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).rolesPostRole(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolesUpdateRoleCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPutRole(body: RolesUpdateRoleCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleDto> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).rolesPutRole(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesDeleteRole(id: number, options?: any) {
            return RolesApiFp(configuration).rolesDeleteRole(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGetRole(id: number, options?: any) {
            return RolesApiFp(configuration).rolesGetRole(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGetRoles(options?: any) {
            return RolesApiFp(configuration).rolesGetRoles(options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolesCreateRoleCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPostRole(body: RolesCreateRoleCommand, options?: any) {
            return RolesApiFp(configuration).rolesPostRole(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolesUpdateRoleCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPutRole(body: RolesUpdateRoleCommand, options?: any) {
            return RolesApiFp(configuration).rolesPutRole(body, options)(fetch, basePath);
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesDeleteRole(id: number, options?: any) {
        return RolesApiFp(this.configuration).rolesDeleteRole(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesGetRole(id: number, options?: any) {
        return RolesApiFp(this.configuration).rolesGetRole(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesGetRoles(options?: any) {
        return RolesApiFp(this.configuration).rolesGetRoles(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolesCreateRoleCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesPostRole(body: RolesCreateRoleCommand, options?: any) {
        return RolesApiFp(this.configuration).rolesPostRole(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolesUpdateRoleCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesPutRole(body: RolesUpdateRoleCommand, options?: any) {
        return RolesApiFp(this.configuration).rolesPutRole(body, options)(this.fetch, this.basePath);
    }

}
/**
 * RssApi - fetch parameter creator
 * @export
 */
export const RssApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rssGetBlogposts(options: any = {}): FetchArgs {
            const localVarPath = `/rss/blogposts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rssGetStories(options: any = {}): FetchArgs {
            const localVarPath = `/rss/stories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rssStories(options: any = {}): FetchArgs {
            const localVarPath = `/rss`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RssApi - functional programming interface
 * @export
 */
export const RssApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rssGetBlogposts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = RssApiFetchParamCreator(configuration).rssGetBlogposts(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rssGetStories(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = RssApiFetchParamCreator(configuration).rssGetStories(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rssStories(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = RssApiFetchParamCreator(configuration).rssStories(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RssApi - factory interface
 * @export
 */
export const RssApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rssGetBlogposts(options?: any) {
            return RssApiFp(configuration).rssGetBlogposts(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rssGetStories(options?: any) {
            return RssApiFp(configuration).rssGetStories(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rssStories(options?: any) {
            return RssApiFp(configuration).rssStories(options)(fetch, basePath);
        },
    };
};

/**
 * RssApi - object-oriented interface
 * @export
 * @class RssApi
 * @extends {BaseAPI}
 */
export class RssApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RssApi
     */
    public rssGetBlogposts(options?: any) {
        return RssApiFp(this.configuration).rssGetBlogposts(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RssApi
     */
    public rssGetStories(options?: any) {
        return RssApiFp(this.configuration).rssGetStories(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RssApi
     */
    public rssStories(options?: any) {
        return RssApiFp(this.configuration).rssStories(options)(this.fetch, this.basePath);
    }

}
/**
 * ShelfStoriesApi - fetch parameter creator
 * @export
 */
export const ShelfStoriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} shelfId 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesAddToShelf(shelfId: number, storyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'shelfId' is not null or undefined
            if (shelfId === null || shelfId === undefined) {
                throw new RequiredError('shelfId','Required parameter shelfId was null or undefined when calling shelfStoriesAddToShelf.');
            }
            // verify required parameter 'storyId' is not null or undefined
            if (storyId === null || storyId === undefined) {
                throw new RequiredError('storyId','Required parameter storyId was null or undefined when calling shelfStoriesAddToShelf.');
            }
            const localVarPath = `/api/shelfstories/{shelfId}/{storyId}`
                .replace(`{${"shelfId"}}`, encodeURIComponent(String(shelfId)))
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesGetUserQuickShelves(storyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'storyId' is not null or undefined
            if (storyId === null || storyId === undefined) {
                throw new RequiredError('storyId','Required parameter storyId was null or undefined when calling shelfStoriesGetUserQuickShelves.');
            }
            const localVarPath = `/api/shelfstories/{storyId}/quick`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesGetUserShelvesPaginated(storyId: number, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storyId' is not null or undefined
            if (storyId === null || storyId === undefined) {
                throw new RequiredError('storyId','Required parameter storyId was null or undefined when calling shelfStoriesGetUserShelvesPaginated.');
            }
            const localVarPath = `/api/shelfstories/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesPing(options: any = {}): FetchArgs {
            const localVarPath = `/api/shelfstories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} shelfId 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesRemoveFromShelf(shelfId: number, storyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'shelfId' is not null or undefined
            if (shelfId === null || shelfId === undefined) {
                throw new RequiredError('shelfId','Required parameter shelfId was null or undefined when calling shelfStoriesRemoveFromShelf.');
            }
            // verify required parameter 'storyId' is not null or undefined
            if (storyId === null || storyId === undefined) {
                throw new RequiredError('storyId','Required parameter storyId was null or undefined when calling shelfStoriesRemoveFromShelf.');
            }
            const localVarPath = `/api/shelfstories/{shelfId}/{storyId}`
                .replace(`{${"shelfId"}}`, encodeURIComponent(String(shelfId)))
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShelfStoriesApi - functional programming interface
 * @export
 */
export const ShelfStoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} shelfId 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesAddToShelf(shelfId: number, storyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShelfStoriesAddBookToShelfResult> {
            const localVarFetchArgs = ShelfStoriesApiFetchParamCreator(configuration).shelfStoriesAddToShelf(shelfId, storyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesGetUserQuickShelves(storyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ShelfDto>> {
            const localVarFetchArgs = ShelfStoriesApiFetchParamCreator(configuration).shelfStoriesGetUserQuickShelves(storyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesGetUserShelvesPaginated(storyId: number, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ShelfStoriesGetPaginatedUserShelvesResult>> {
            const localVarFetchArgs = ShelfStoriesApiFetchParamCreator(configuration).shelfStoriesGetUserShelvesPaginated(storyId, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ShelfStoriesApiFetchParamCreator(configuration).shelfStoriesPing(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} shelfId 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesRemoveFromShelf(shelfId: number, storyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShelfStoriesRemoveBookFromShelfResult> {
            const localVarFetchArgs = ShelfStoriesApiFetchParamCreator(configuration).shelfStoriesRemoveFromShelf(shelfId, storyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ShelfStoriesApi - factory interface
 * @export
 */
export const ShelfStoriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} shelfId 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesAddToShelf(shelfId: number, storyId: number, options?: any) {
            return ShelfStoriesApiFp(configuration).shelfStoriesAddToShelf(shelfId, storyId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesGetUserQuickShelves(storyId: number, options?: any) {
            return ShelfStoriesApiFp(configuration).shelfStoriesGetUserQuickShelves(storyId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesGetUserShelvesPaginated(storyId: number, page?: number, options?: any) {
            return ShelfStoriesApiFp(configuration).shelfStoriesGetUserShelvesPaginated(storyId, page, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesPing(options?: any) {
            return ShelfStoriesApiFp(configuration).shelfStoriesPing(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} shelfId 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelfStoriesRemoveFromShelf(shelfId: number, storyId: number, options?: any) {
            return ShelfStoriesApiFp(configuration).shelfStoriesRemoveFromShelf(shelfId, storyId, options)(fetch, basePath);
        },
    };
};

/**
 * ShelfStoriesApi - object-oriented interface
 * @export
 * @class ShelfStoriesApi
 * @extends {BaseAPI}
 */
export class ShelfStoriesApi extends BaseAPI {
    /**
     * 
     * @param {number} shelfId 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelfStoriesApi
     */
    public shelfStoriesAddToShelf(shelfId: number, storyId: number, options?: any) {
        return ShelfStoriesApiFp(this.configuration).shelfStoriesAddToShelf(shelfId, storyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelfStoriesApi
     */
    public shelfStoriesGetUserQuickShelves(storyId: number, options?: any) {
        return ShelfStoriesApiFp(this.configuration).shelfStoriesGetUserQuickShelves(storyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} storyId 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelfStoriesApi
     */
    public shelfStoriesGetUserShelvesPaginated(storyId: number, page?: number, options?: any) {
        return ShelfStoriesApiFp(this.configuration).shelfStoriesGetUserShelvesPaginated(storyId, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelfStoriesApi
     */
    public shelfStoriesPing(options?: any) {
        return ShelfStoriesApiFp(this.configuration).shelfStoriesPing(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} shelfId 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelfStoriesApi
     */
    public shelfStoriesRemoveFromShelf(shelfId: number, storyId: number, options?: any) {
        return ShelfStoriesApiFp(this.configuration).shelfStoriesRemoveFromShelf(shelfId, storyId, options)(this.fetch, this.basePath);
    }

}
/**
 * ShelvesApi - fetch parameter creator
 * @export
 */
export const ShelvesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesDeleteShelf(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling shelvesDeleteShelf.');
            }
            const localVarPath = `/api/shelves/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesGetShelf(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling shelvesGetShelf.');
            }
            const localVarPath = `/api/shelves/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesGetUserShelves(name: string, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling shelvesGetUserShelves.');
            }
            const localVarPath = `/api/shelves/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShelvesCreateShelfCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesPostShelf(body: ShelvesCreateShelfCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling shelvesPostShelf.');
            }
            const localVarPath = `/api/shelves`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShelvesCreateShelfCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShelvesUpdateShelfCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesPutShelf(body: ShelvesUpdateShelfCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling shelvesPutShelf.');
            }
            const localVarPath = `/api/shelves`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShelvesUpdateShelfCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShelvesApi - functional programming interface
 * @export
 */
export const ShelvesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesDeleteShelf(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = ShelvesApiFetchParamCreator(configuration).shelvesDeleteShelf(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesGetShelf(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShelfDto> {
            const localVarFetchArgs = ShelvesApiFetchParamCreator(configuration).shelvesGetShelf(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesGetUserShelves(name: string, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ShelfDto>> {
            const localVarFetchArgs = ShelvesApiFetchParamCreator(configuration).shelvesGetUserShelves(name, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ShelvesCreateShelfCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesPostShelf(body: ShelvesCreateShelfCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShelfDto> {
            const localVarFetchArgs = ShelvesApiFetchParamCreator(configuration).shelvesPostShelf(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ShelvesUpdateShelfCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesPutShelf(body: ShelvesUpdateShelfCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShelfDto> {
            const localVarFetchArgs = ShelvesApiFetchParamCreator(configuration).shelvesPutShelf(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ShelvesApi - factory interface
 * @export
 */
export const ShelvesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesDeleteShelf(id: number, options?: any) {
            return ShelvesApiFp(configuration).shelvesDeleteShelf(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesGetShelf(id: number, options?: any) {
            return ShelvesApiFp(configuration).shelvesGetShelf(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesGetUserShelves(name: string, page?: number, options?: any) {
            return ShelvesApiFp(configuration).shelvesGetUserShelves(name, page, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ShelvesCreateShelfCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesPostShelf(body: ShelvesCreateShelfCommand, options?: any) {
            return ShelvesApiFp(configuration).shelvesPostShelf(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ShelvesUpdateShelfCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shelvesPutShelf(body: ShelvesUpdateShelfCommand, options?: any) {
            return ShelvesApiFp(configuration).shelvesPutShelf(body, options)(fetch, basePath);
        },
    };
};

/**
 * ShelvesApi - object-oriented interface
 * @export
 * @class ShelvesApi
 * @extends {BaseAPI}
 */
export class ShelvesApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelvesApi
     */
    public shelvesDeleteShelf(id: number, options?: any) {
        return ShelvesApiFp(this.configuration).shelvesDeleteShelf(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelvesApi
     */
    public shelvesGetShelf(id: number, options?: any) {
        return ShelvesApiFp(this.configuration).shelvesGetShelf(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelvesApi
     */
    public shelvesGetUserShelves(name: string, page?: number, options?: any) {
        return ShelvesApiFp(this.configuration).shelvesGetUserShelves(name, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ShelvesCreateShelfCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelvesApi
     */
    public shelvesPostShelf(body: ShelvesCreateShelfCommand, options?: any) {
        return ShelvesApiFp(this.configuration).shelvesPostShelf(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ShelvesUpdateShelfCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShelvesApi
     */
    public shelvesPutShelf(body: ShelvesUpdateShelfCommand, options?: any) {
        return ShelvesApiFp(this.configuration).shelvesPutShelf(body, options)(this.fetch, this.basePath);
    }

}
/**
 * SignInApi - fetch parameter creator
 * @export
 */
export const SignInApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInGetSignIn(name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignInApi - functional programming interface
 * @export
 */
export const SignInApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInGetSignIn(name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SignInGetSignInDataResult> {
            const localVarFetchArgs = SignInApiFetchParamCreator(configuration).signInGetSignIn(name, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SignInApi - factory interface
 * @export
 */
export const SignInApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInGetSignIn(name?: string, options?: any) {
            return SignInApiFp(configuration).signInGetSignIn(name, options)(fetch, basePath);
        },
    };
};

/**
 * SignInApi - object-oriented interface
 * @export
 * @class SignInApi
 * @extends {BaseAPI}
 */
export class SignInApi extends BaseAPI {
    /**
     * 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInApi
     */
    public signInGetSignIn(name?: string, options?: any) {
        return SignInApiFp(this.configuration).signInGetSignIn(name, options)(this.fetch, this.basePath);
    }

}
/**
 * SubscriptionsApi - fetch parameter creator
 * @export
 */
export const SubscriptionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsIsSubscribedToThread(threadId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/subscriptions/thread`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (threadId !== undefined) {
                localVarQueryParameter['ThreadId'] = threadId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPing(options: any = {}): FetchArgs {
            const localVarPath = `/api/subscriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscriptionsSubscribeCommentsThreadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsSubscribeThread(body: SubscriptionsSubscribeCommentsThreadCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling subscriptionsSubscribeThread.');
            }
            const localVarPath = `/api/subscriptions/thread`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscriptionsSubscribeCommentsThreadCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscriptionsUnsubscribeCommentsThreadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsUnsubscribeThread(body: SubscriptionsUnsubscribeCommentsThreadCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling subscriptionsUnsubscribeThread.');
            }
            const localVarPath = `/api/subscriptions/thread`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscriptionsUnsubscribeCommentsThreadCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsIsSubscribedToThread(threadId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).subscriptionsIsSubscribedToThread(threadId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).subscriptionsPing(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SubscriptionsSubscribeCommentsThreadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsSubscribeThread(body: SubscriptionsSubscribeCommentsThreadCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).subscriptionsSubscribeThread(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SubscriptionsUnsubscribeCommentsThreadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsUnsubscribeThread(body: SubscriptionsUnsubscribeCommentsThreadCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).subscriptionsUnsubscribeThread(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [threadId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsIsSubscribedToThread(threadId?: number, options?: any) {
            return SubscriptionsApiFp(configuration).subscriptionsIsSubscribedToThread(threadId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPing(options?: any) {
            return SubscriptionsApiFp(configuration).subscriptionsPing(options)(fetch, basePath);
        },
        /**
         * 
         * @param {SubscriptionsSubscribeCommentsThreadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsSubscribeThread(body: SubscriptionsSubscribeCommentsThreadCommand, options?: any) {
            return SubscriptionsApiFp(configuration).subscriptionsSubscribeThread(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SubscriptionsUnsubscribeCommentsThreadCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsUnsubscribeThread(body: SubscriptionsUnsubscribeCommentsThreadCommand, options?: any) {
            return SubscriptionsApiFp(configuration).subscriptionsUnsubscribeThread(body, options)(fetch, basePath);
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @param {number} [threadId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsIsSubscribedToThread(threadId?: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).subscriptionsIsSubscribedToThread(threadId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsPing(options?: any) {
        return SubscriptionsApiFp(this.configuration).subscriptionsPing(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SubscriptionsSubscribeCommentsThreadCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsSubscribeThread(body: SubscriptionsSubscribeCommentsThreadCommand, options?: any) {
        return SubscriptionsApiFp(this.configuration).subscriptionsSubscribeThread(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SubscriptionsUnsubscribeCommentsThreadCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsUnsubscribeThread(body: SubscriptionsUnsubscribeCommentsThreadCommand, options?: any) {
        return SubscriptionsApiFp(this.configuration).subscriptionsUnsubscribeThread(body, options)(this.fetch, this.basePath);
    }

}
/**
 * TagsApi - fetch parameter creator
 * @export
 */
export const TagsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDeleteTag(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagsDeleteTag.');
            }
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetAll(options: any = {}): FetchArgs {
            const localVarPath = `/api/tags/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetStoryTags(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagsGetStoryTags.');
            }
            const localVarPath = `/api/tags/story/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetTag(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagsGetTag.');
            }
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetTags(page?: number, perPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['PerPage'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TagsCreateTagCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPostTag(body: TagsCreateTagCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tagsPostTag.');
            }
            const localVarPath = `/api/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TagsCreateTagCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TagsUpdateTagCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPutTag(body: TagsUpdateTagCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tagsPutTag.');
            }
            const localVarPath = `/api/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TagsUpdateTagCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDeleteTag(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsDeleteTag(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetAll(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TagDto>> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsGetAll(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetStoryTags(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TagDto>> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsGetStoryTags(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetTag(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TagDto> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsGetTag(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetTags(page?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TagDto>> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsGetTags(page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TagsCreateTagCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPostTag(body: TagsCreateTagCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsPostTag(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TagsUpdateTagCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPutTag(body: TagsUpdateTagCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsPutTag(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDeleteTag(id: number, options?: any) {
            return TagsApiFp(configuration).tagsDeleteTag(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetAll(options?: any) {
            return TagsApiFp(configuration).tagsGetAll(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetStoryTags(id: number, options?: any) {
            return TagsApiFp(configuration).tagsGetStoryTags(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetTag(id: number, options?: any) {
            return TagsApiFp(configuration).tagsGetTag(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGetTags(page?: number, perPage?: number, options?: any) {
            return TagsApiFp(configuration).tagsGetTags(page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TagsCreateTagCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPostTag(body: TagsCreateTagCommand, options?: any) {
            return TagsApiFp(configuration).tagsPostTag(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TagsUpdateTagCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPutTag(body: TagsUpdateTagCommand, options?: any) {
            return TagsApiFp(configuration).tagsPutTag(body, options)(fetch, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsDeleteTag(id: number, options?: any) {
        return TagsApiFp(this.configuration).tagsDeleteTag(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGetAll(options?: any) {
        return TagsApiFp(this.configuration).tagsGetAll(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGetStoryTags(id: number, options?: any) {
        return TagsApiFp(this.configuration).tagsGetStoryTags(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGetTag(id: number, options?: any) {
        return TagsApiFp(this.configuration).tagsGetTag(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGetTags(page?: number, perPage?: number, options?: any) {
        return TagsApiFp(this.configuration).tagsGetTags(page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TagsCreateTagCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPostTag(body: TagsCreateTagCommand, options?: any) {
        return TagsApiFp(this.configuration).tagsPostTag(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TagsUpdateTagCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPutTag(body: TagsUpdateTagCommand, options?: any) {
        return TagsApiFp(this.configuration).tagsPutTag(body, options)(this.fetch, this.basePath);
    }

}
/**
 * UserActivityApi - fetch parameter creator
 * @export
 */
export const UserActivityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userActivityPing(options: any = {}): FetchArgs {
            const localVarPath = `/api/useractivity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userActivityUpdateLastActive(options: any = {}): FetchArgs {
            const localVarPath = `/api/useractivity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserActivityApi - functional programming interface
 * @export
 */
export const UserActivityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userActivityPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UserActivityApiFetchParamCreator(configuration).userActivityPing(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userActivityUpdateLastActive(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = UserActivityApiFetchParamCreator(configuration).userActivityUpdateLastActive(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserActivityApi - factory interface
 * @export
 */
export const UserActivityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userActivityPing(options?: any) {
            return UserActivityApiFp(configuration).userActivityPing(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userActivityUpdateLastActive(options?: any) {
            return UserActivityApiFp(configuration).userActivityUpdateLastActive(options)(fetch, basePath);
        },
    };
};

/**
 * UserActivityApi - object-oriented interface
 * @export
 * @class UserActivityApi
 * @extends {BaseAPI}
 */
export class UserActivityApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserActivityApi
     */
    public userActivityPing(options?: any) {
        return UserActivityApiFp(this.configuration).userActivityPing(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserActivityApi
     */
    public userActivityUpdateLastActive(options?: any) {
        return UserActivityApiFp(this.configuration).userActivityUpdateLastActive(options)(this.fetch, this.basePath);
    }

}
/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BanData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersBanUser(body: BanData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling usersBanUser.');
            }
            const localVarPath = `/api/users/ban`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BanData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BlockPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersBlockUser(body: BlockPostData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling usersBlockUser.');
            }
            const localVarPath = `/api/users/block`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BlockPostData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BlockPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFollowUser(body: BlockPostData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling usersFollowUser.');
            }
            const localVarPath = `/api/users/follow`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BlockPostData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RoleData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManageRoles(body: RoleData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling usersManageRoles.');
            }
            const localVarPath = `/api/users/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RoleData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BanData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMuteUser(body: BanData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling usersMuteUser.');
            }
            const localVarPath = `/api/users/mute`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BanData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPing(options: any = {}): FetchArgs {
            const localVarPath = `/api/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BanData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersBanUser(body: BanData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersBanUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {BlockPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersBlockUser(body: BlockPostData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersBlockUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {BlockPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFollowUser(body: BlockPostData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersFollowUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RoleData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManageRoles(body: RoleData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersManageRoles(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {BanData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMuteUser(body: BanData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersMuteUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersPing(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {BanData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersBanUser(body: BanData, options?: any) {
            return UsersApiFp(configuration).usersBanUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {BlockPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersBlockUser(body: BlockPostData, options?: any) {
            return UsersApiFp(configuration).usersBlockUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {BlockPostData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFollowUser(body: BlockPostData, options?: any) {
            return UsersApiFp(configuration).usersFollowUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RoleData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersManageRoles(body: RoleData, options?: any) {
            return UsersApiFp(configuration).usersManageRoles(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {BanData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMuteUser(body: BanData, options?: any) {
            return UsersApiFp(configuration).usersMuteUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPing(options?: any) {
            return UsersApiFp(configuration).usersPing(options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {BanData} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersBanUser(body: BanData, options?: any) {
        return UsersApiFp(this.configuration).usersBanUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {BlockPostData} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersBlockUser(body: BlockPostData, options?: any) {
        return UsersApiFp(this.configuration).usersBlockUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {BlockPostData} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersFollowUser(body: BlockPostData, options?: any) {
        return UsersApiFp(this.configuration).usersFollowUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RoleData} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersManageRoles(body: RoleData, options?: any) {
        return UsersApiFp(this.configuration).usersManageRoles(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {BanData} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMuteUser(body: BanData, options?: any) {
        return UsersApiFp(this.configuration).usersMuteUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPing(options?: any) {
        return UsersApiFp(this.configuration).usersPing(options)(this.fetch, this.basePath);
    }

}
/**
 * VotesApi - fetch parameter creator
 * @export
 */
export const VotesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {VotesDeleteVoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesDeleteVote(body: VotesDeleteVoteCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling votesDeleteVote.');
            }
            const localVarPath = `/api/votes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VotesDeleteVoteCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesGetVotes(storyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'storyId' is not null or undefined
            if (storyId === null || storyId === undefined) {
                throw new RequiredError('storyId','Required parameter storyId was null or undefined when calling votesGetVotes.');
            }
            const localVarPath = `/api/votes/{storyId}`
                .replace(`{${"storyId"}}`, encodeURIComponent(String(storyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VotesCreateVoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesPostVote(body: VotesCreateVoteCommand, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling votesPostVote.');
            }
            const localVarPath = `/api/votes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VotesCreateVoteCommand" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VotesApi - functional programming interface
 * @export
 */
export const VotesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {VotesDeleteVoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesDeleteVote(body: VotesDeleteVoteCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VotesDeleteVoteResult> {
            const localVarFetchArgs = VotesApiFetchParamCreator(configuration).votesDeleteVote(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesGetVotes(storyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VotesGetVotesResult> {
            const localVarFetchArgs = VotesApiFetchParamCreator(configuration).votesGetVotes(storyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {VotesCreateVoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesPostVote(body: VotesCreateVoteCommand, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VotesCreateVoteResult> {
            const localVarFetchArgs = VotesApiFetchParamCreator(configuration).votesPostVote(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VotesApi - factory interface
 * @export
 */
export const VotesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {VotesDeleteVoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesDeleteVote(body: VotesDeleteVoteCommand, options?: any) {
            return VotesApiFp(configuration).votesDeleteVote(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} storyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesGetVotes(storyId: number, options?: any) {
            return VotesApiFp(configuration).votesGetVotes(storyId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {VotesCreateVoteCommand} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesPostVote(body: VotesCreateVoteCommand, options?: any) {
            return VotesApiFp(configuration).votesPostVote(body, options)(fetch, basePath);
        },
    };
};

/**
 * VotesApi - object-oriented interface
 * @export
 * @class VotesApi
 * @extends {BaseAPI}
 */
export class VotesApi extends BaseAPI {
    /**
     * 
     * @param {VotesDeleteVoteCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VotesApi
     */
    public votesDeleteVote(body: VotesDeleteVoteCommand, options?: any) {
        return VotesApiFp(this.configuration).votesDeleteVote(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} storyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VotesApi
     */
    public votesGetVotes(storyId: number, options?: any) {
        return VotesApiFp(this.configuration).votesGetVotes(storyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {VotesCreateVoteCommand} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VotesApi
     */
    public votesPostVote(body: VotesCreateVoteCommand, options?: any) {
        return VotesApiFp(this.configuration).votesPostVote(body, options)(this.fetch, this.basePath);
    }

}
