{
  "version": 3,
  "sources": ["..\\..\\FrontendCode\\typescript\\src-helpers\\dom.ts", "..\\..\\FrontendCode\\typescript\\src\\input-progressbars.ts"],
  "sourcesContent": [
    "const parser = new DOMParser();\r\n\r\nexport const parseDom = (html: string): HTMLElement => {\r\n\treturn parser.parseFromString(html, \"text/html\").body.firstElementChild as HTMLElement;\r\n};\r\n",
    "import { parseDom } from \"@h/dom\";\r\n\r\ntype InputType = \"validated\" | \"file\" | \"regular\";\r\n\r\nconst properSplit = (value: string, separator: string | RegExp) =>\r\n\t!value || value.length <= 0 ? [] : value.split(separator);\r\n\r\nconst inputs: (HTMLInputElement | HTMLTextAreaElement)[] = [\r\n\t...document.querySelectorAll(\"input.o-form-control:not([disabled]):not([nobar])\"),\r\n\t...document.querySelectorAll(\"textarea.o-form-control:not([disabled]):not([nobar])\"),\r\n] as (HTMLInputElement | HTMLTextAreaElement)[];\r\n\r\nfor (const input of inputs) {\r\n\tconsole.log(`Attaching ${input.type}`);\r\n\r\n\tlet type: InputType;\r\n\tif (input.dataset.maxCount || input.dataset.valLengthMax || input.dataset.valMaxlengthMax) {\r\n\t\t// One of the validation parameters is set so it's a validated input\r\n\t\ttype = \"validated\";\r\n\t} else if (input.dataset.valFilesizeMax && input.type === \"file\") {\r\n\t\t// File size validation parameter is set and the input type is file, so it's a file\r\n\t\ttype = \"file\";\r\n\t} else {\r\n\t\t// It's something else entirely\r\n\t\ttype = \"regular\";\r\n\t}\r\n\r\n\t// If there's no count specified, get max length. If that's not there, just use 0.\r\n\tconst max: number = {\r\n\t\tvalidated: Number(input.dataset.maxCount ?? input.dataset.valLengthMax ?? input.dataset.valMaxlengthMax),\r\n\t\tfile: Number(input.dataset.valFilesizeMax),\r\n\t\tregular: input.maxLength ?? 0,\r\n\t}[type];\r\n\r\n\t// Sometimes we have the minimum value as well, if not let's just ensure it's not 0 or less\r\n\tconst min: number = Number(input.dataset.valLengthMin) ?? 0;\r\n\r\n\t// Function to get the current size\r\n\tconst currentSize: () => number = (): number => {\r\n\t\tif (input.dataset.maxCount) {\r\n\t\t\t// `data-max-count` is set, so we're counting comma-separated values\r\n\t\t\treturn input.value.split(\",\").length;\r\n\t\t}\r\n\t\tif (input.dataset.valFilesizeMax && input.type === \"file\") {\r\n\t\t\t// It's a file input with maximum file size defined, so we get the file size\r\n\t\t\treturn (input as HTMLInputElement).files[0]?.size ?? 0;\r\n\t\t}\r\n\t\t// Just a regular ol' input, get the value length\r\n\t\treturn input.value.length;\r\n\t};\r\n\r\n\t// Create the main container\r\n\tconst counter: HTMLElement = parseDom('<div class=\"counter\"></div>');\r\n\r\n\t// Create the progress bar proper\r\n\tconst progress: HTMLElement = parseDom('<div class=\"o-progress-bar\"></div>');\r\n\r\n\t// Create the character counter\r\n\tconst count: HTMLElement = parseDom(`<span>${currentSize()}/${max}${type === \"file\" ? \" bytes\" : \"\"}</span>`);\r\n\r\n\t// Append the progress bar to the container\r\n\tcounter.appendChild(progress);\r\n\r\n\t// If the `data-wordcount` property is there, create a wordcount element and append it\r\n\tlet wordcount: HTMLElement;\r\n\tif (input.dataset.wordcount) {\r\n\t\twordcount = parseDom(`<span>${properSplit(input.value, /\\s+/).length.toString()} words</span>`);\r\n\t\tcounter.appendChild(wordcount);\r\n\t}\r\n\r\n\t// Append character counter\r\n\tcounter.appendChild(count);\r\n\r\n\t// Append the whole thing right after the target input element\r\n\tinput.after(counter);\r\n\r\n\t//\r\n\tconst updateMetrics = () => {\r\n\t\tconst length = currentSize();\r\n\t\tconst suffix = type === \"file\" ? \" bytes\" : \"\";\r\n\t\t// Update character counter\r\n\t\tcount.innerText = `${length}/${max}${suffix}`;\r\n\r\n\t\t// Update progress bar progress\r\n\t\tprogress.style.width = `${Math.min(100, 100 * (length / max))}%`;\r\n\r\n\t\t// If `data-wordcount` has been specified, update that as well\r\n\t\tif (input.dataset.wordcount) {\r\n\t\t\tconst words = (properSplit(input.value, /\\s+/) ?? []).length.toString();\r\n\t\t\twordcount.innerText = `${words} words`;\r\n\t\t}\r\n\r\n\t\t// Check if the input is valid\r\n\t\tcounter.classList.toggle(\"invalid\", length < min || length > max);\r\n\t};\r\n\r\n\t// Listen to input\r\n\tconsole.log(`Listening to ${input.type}`);\r\n\tinput.addEventListener(\"input\", updateMetrics);\r\n\tupdateMetrics();\r\n}\r\n"
  ],
  "mappings": "AAAA,IAAM,EAAS,IAAI,UAEN,EAAW,CAAC,IAA8B,CACtD,OAAO,EAAO,gBAAgB,EAAM,WAAW,EAAE,KAAK,mBCCvD,IAAM,EAAc,CAAC,EAAe,KAClC,GAAS,EAAM,QAAU,EAAI,CAAC,EAAI,EAAM,MAAM,CAAS,EAEnD,EAAqD,CAC1D,GAAG,SAAS,iBAAiB,mDAAmD,EAChF,GAAG,SAAS,iBAAiB,sDAAsD,CACpF,EAEA,QAAW,KAAS,EAAQ,CAC3B,QAAQ,IAAI,aAAa,EAAM,MAAM,EAErC,IAAI,EACJ,GAAI,EAAM,QAAQ,UAAY,EAAM,QAAQ,cAAgB,EAAM,QAAQ,gBAEzE,EAAO,YACD,QAAI,EAAM,QAAQ,gBAAkB,EAAM,OAAS,OAEzD,EAAO,OAGP,OAAO,UAIR,IAAM,EAAc,CACnB,UAAW,OAAO,EAAM,QAAQ,UAAY,EAAM,QAAQ,cAAgB,EAAM,QAAQ,eAAe,EACvG,KAAM,OAAO,EAAM,QAAQ,cAAc,EACzC,QAAS,EAAM,WAAa,CAC7B,EAAE,GAGI,EAAc,OAAO,EAAM,QAAQ,YAAY,GAAK,EAGpD,EAA4B,IAAc,CAC/C,GAAI,EAAM,QAAQ,SAEjB,OAAO,EAAM,MAAM,MAAM,GAAG,EAAE,OAE/B,GAAI,EAAM,QAAQ,gBAAkB,EAAM,OAAS,OAElD,OAAQ,EAA2B,MAAM,IAAI,MAAQ,EAGtD,OAAO,EAAM,MAAM,QAId,EAAuB,EAAS,6BAA6B,EAG7D,EAAwB,EAAS,oCAAoC,EAGrE,EAAqB,EAAS,SAAS,EAAY,KAAK,IAAM,IAAS,OAAS,SAAW,WAAW,EAG5G,EAAQ,YAAY,CAAQ,EAG5B,IAAI,EACJ,GAAI,EAAM,QAAQ,UACjB,EAAY,EAAS,SAAS,EAAY,EAAM,MAAO,KAAK,EAAE,OAAO,SAAS,gBAAgB,EAC9F,EAAQ,YAAY,CAAS,EAI9B,EAAQ,YAAY,CAAK,EAGzB,EAAM,MAAM,CAAO,EAGnB,IAAM,EAAgB,IAAM,CAC3B,IAAM,EAAS,EAAY,EACrB,EAAS,IAAS,OAAS,SAAW,GAQ5C,GANA,EAAM,UAAY,GAAG,KAAU,IAAM,IAGrC,EAAS,MAAM,MAAQ,GAAG,KAAK,IAAI,IAAK,KAAO,EAAS,EAAI,KAGxD,EAAM,QAAQ,UAAW,CAC5B,IAAM,GAAS,EAAY,EAAM,MAAO,KAAK,GAAK,CAAC,GAAG,OAAO,SAAS,EACtE,EAAU,UAAY,GAAG,UAI1B,EAAQ,UAAU,OAAO,UAAW,EAAS,GAAO,EAAS,CAAG,GAIjE,QAAQ,IAAI,gBAAgB,EAAM,MAAM,EACxC,EAAM,iBAAiB,QAAS,CAAa,EAC7C,EAAc",
  "debugId": "1757F35212B9CFB764756E2164756E21",
  "names": []
}